<!DOCTYPE html>

<html class="writer-html5" lang="en">
<head>
<meta charset="utf-8"/><meta content="Docutils 0.17.1: http://docutils.sourceforge.net/" name="generator"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>merlion.utils package — Merlion 1.1.1 documentation</title>
<link href="_static/pygments.css" rel="stylesheet" type="text/css"/>
<link href="_static/css/theme.css" rel="stylesheet" type="text/css"/>
<!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
<script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
<script src="_static/jquery.js"></script>
<script src="_static/underscore.js"></script>
<script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
<script src="_static/doctools.js"></script>
<script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
<script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
<script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script src="_static/js/theme.js"></script>
<link href="genindex.html" rel="index" title="Index"/>
<link href="search.html" rel="search" title="Search"/>
<link href="ts_datasets.html" rel="next" title="ts_datasets: Easy Data Loading"/>
<link href="merlion.evaluate.html" rel="prev" title="merlion.evaluate package"/>
</head>
<body class="wy-body-for-nav">
<div class="wy-grid-for-nav">
<nav class="wy-nav-side" data-toggle="wy-nav-shift">
<div class="wy-side-scroll">
<div class="wy-side-nav-search">
<a class="icon icon-home" href="index.html"> Merlion
          </a>
<div class="version">
                v1.1.1
              </div>
<div role="search">
<form action="search.html" class="wy-form" id="rtd-search-form" method="get">
<input name="q" placeholder="Search docs" type="text"/>
<input name="check_keywords" type="hidden" value="yes"/>
<input name="area" type="hidden" value="default"/>
</form>
</div>
</div><div aria-label="Navigation menu" class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation">
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="merlion.html">merlion: Time Series Intelligence</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="merlion.html#subpackages">Subpackages</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="merlion.models.html">merlion.models package</a></li>
<li class="toctree-l3"><a class="reference internal" href="merlion.transform.html">merlion.transform package</a></li>
<li class="toctree-l3"><a class="reference internal" href="merlion.post_process.html">merlion.post_process package</a></li>
<li class="toctree-l3"><a class="reference internal" href="merlion.evaluate.html">merlion.evaluate package</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">merlion.utils package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#submodules">Submodules</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-merlion.utils.conj_priors">merlion.utils.conj_priors module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-merlion.utils.istat">merlion.utils.istat module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-merlion.utils.misc">merlion.utils.misc module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-merlion.utils.resample">merlion.utils.resample module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-merlion.utils.time_series">merlion.utils.time_series module</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="merlion.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="merlion.html#module-merlion.plot">merlion.plot module</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ts_datasets.html">ts_datasets: Easy Data Loading</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials.html">Tutorials &amp; Example Code</a></li>
</ul>
</div>
</div>
</nav>
<section class="wy-nav-content-wrap" data-toggle="wy-nav-shift"><nav aria-label="Mobile navigation menu" class="wy-nav-top">
<i class="fa fa-bars" data-toggle="wy-nav-top"></i>
<a href="index.html">Merlion</a>
</nav>
<div class="wy-nav-content">
<div class="rst-content">
<div aria-label="Page navigation" role="navigation">
<ul class="wy-breadcrumbs">
<li><a class="icon icon-home" href="index.html"></a> »</li>
<li><a href="merlion.html">merlion: Time Series Intelligence</a> »</li>
<li>merlion.utils package</li>
<li class="wy-breadcrumbs-aside">
<a href="_sources/merlion.utils.rst.txt" rel="nofollow"> View page source</a>
</li>
</ul>
<hr/>
</div>
<div class="document" itemscope="itemscope" itemtype="http://schema.org/Article" role="main">
<div itemprop="articleBody">
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<section id="merlion-utils-package">
<h1>merlion.utils package<a class="headerlink" href="#merlion-utils-package" title="Permalink to this heading"></a></h1>
<p>This package contains various utilities, including the <a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a> class and
utilities for resampling time series.</p>
<span class="target" id="module-merlion.utils"></span><section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this heading"></a></h2>
</section>
<section id="module-merlion.utils.conj_priors">
<span id="merlion-utils-conj-priors-module"></span><h2>merlion.utils.conj_priors module<a class="headerlink" href="#module-merlion.utils.conj_priors" title="Permalink to this heading"></a></h2>
<p>Implementations of Bayesian conjugate priors &amp; their online update rules.</p>
<table class="autosummary longtable docutils align-default">
<colgroup>
<col style="width: 10%"/>
<col style="width: 90%"/>
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#merlion.utils.conj_priors.ConjPrior" title="merlion.utils.conj_priors.ConjPrior"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ConjPrior</span></code></a>([sample])</p></td>
<td><p>Abstract base class for a Bayesian conjugate prior.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#merlion.utils.conj_priors.BetaBernoulli" title="merlion.utils.conj_priors.BetaBernoulli"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BetaBernoulli</span></code></a>([sample])</p></td>
<td><p>Beta-Bernoulli conjugate prior for binary data.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#merlion.utils.conj_priors.NormInvGamma" title="merlion.utils.conj_priors.NormInvGamma"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NormInvGamma</span></code></a>([sample])</p></td>
<td><p>Normal-InverseGamma conjugate prior.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#merlion.utils.conj_priors.MVNormInvWishart" title="merlion.utils.conj_priors.MVNormInvWishart"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MVNormInvWishart</span></code></a>([sample])</p></td>
<td><p>Multivariate Normal-InverseWishart conjugate prior.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#merlion.utils.conj_priors.BayesianLinReg" title="merlion.utils.conj_priors.BayesianLinReg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BayesianLinReg</span></code></a>([sample])</p></td>
<td><p>Bayesian Ordinary Linear Regression conjugate prior, which models a univariate input as a function of time.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#merlion.utils.conj_priors.BayesianMVLinReg" title="merlion.utils.conj_priors.BayesianMVLinReg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BayesianMVLinReg</span></code></a>([sample])</p></td>
<td><p>Bayesian multivariate linear regression conjugate prior, which models a multivariate input as a function of time.</p></td>
</tr>
</tbody>
</table>
<dl class="py class">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.ConjPrior">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">merlion.utils.conj_priors.</span></span><span class="sig-name descname"><span class="pre">ConjPrior</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sample</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.ConjPrior" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">ABC</span></code></p>
<p>Abstract base class for a Bayesian conjugate prior.
Can be used with either <a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a> or <code class="docutils literal notranslate"><span class="pre">numpy</span></code> arrays directly.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>sample</strong> – a sample used to initialize the prior.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.ConjPrior.to_dict">
<span class="sig-name descname"><span class="pre">to_dict</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.ConjPrior.to_dict" title="Permalink to this definition"></a></dt>
<dd></dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.ConjPrior.from_dict">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_dict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state_dict</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.ConjPrior.from_dict" title="Permalink to this definition"></a></dt>
<dd></dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.ConjPrior.get_time_series_values">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_time_series_values</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.ConjPrior.get_time_series_values" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>numpy array representing the input <code class="docutils literal notranslate"><span class="pre">x</span></code></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.ConjPrior.process_time_series">
<span class="sig-name descname"><span class="pre">process_time_series</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.ConjPrior.process_time_series" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>]</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">(t,</span> <span class="pre">x)</span></code>, where <code class="docutils literal notranslate"><span class="pre">t</span></code> is a normalized list of timestamps, and <code class="docutils literal notranslate"><span class="pre">x</span></code> is a <code class="docutils literal notranslate"><span class="pre">numpy</span></code> array
representing the input</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.ConjPrior.posterior">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">posterior</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_rv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_updated</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.ConjPrior.posterior" title="Permalink to this definition"></a></dt>
<dd><p>Predictive posterior (log) PDF for new observations, or the <code class="docutils literal notranslate"><span class="pre">scipy.stats</span></code> random variable where applicable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – value(s) to evaluate posterior at (<code class="docutils literal notranslate"><span class="pre">None</span></code> implies that we want to return the random variable)</p></li>
<li><p><strong>return_rv</strong> – whether to return the random variable directly</p></li>
<li><p><strong>log</strong> – whether to return the log PDF (instead of the PDF)</p></li>
<li><p><strong>return_updated</strong> – whether to return an updated version of the conjugate prior as well</p></li>
</ul>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.ConjPrior.update">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.ConjPrior.update" title="Permalink to this definition"></a></dt>
<dd><p>Update the conjugate prior based on new observations x.</p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.ConjPrior.forecast">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">forecast</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_stamps</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.ConjPrior.forecast" title="Permalink to this definition"></a></dt>
<dd><p>Return a posterior predictive interval for the time stamps given.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>time_stamps</strong> – a list of time stamps</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code>[<a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a>, <a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a>]</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">(forecast,</span> <span class="pre">stderr)</span></code>, where <code class="docutils literal notranslate"><span class="pre">forecast</span></code> is the expected posterior value and <code class="docutils literal notranslate"><span class="pre">stderr</span></code> is the
standard error of that forecast.</p>
</dd>
</dl>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.ScalarConjPrior">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">merlion.utils.conj_priors.</span></span><span class="sig-name descname"><span class="pre">ScalarConjPrior</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sample</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.ScalarConjPrior" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#merlion.utils.conj_priors.ConjPrior" title="merlion.utils.conj_priors.ConjPrior"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConjPrior</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ABC</span></code></p>
<p>Abstract base class for a Bayesian conjugate prior for a scalar random variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>sample</strong> – a sample used to initialize the prior.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.ScalarConjPrior.process_time_series">
<span class="sig-name descname"><span class="pre">process_time_series</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.ScalarConjPrior.process_time_series" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">(t,</span> <span class="pre">x)</span></code>, where <code class="docutils literal notranslate"><span class="pre">t</span></code> is a normalized list of timestamps, and <code class="docutils literal notranslate"><span class="pre">x</span></code> is a <code class="docutils literal notranslate"><span class="pre">numpy</span></code> array
representing the input</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.ScalarConjPrior.get_time_series_values">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_time_series_values</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.ScalarConjPrior.get_time_series_values" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>numpy array representing the input <code class="docutils literal notranslate"><span class="pre">x</span></code></p>
</dd>
</dl>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.BetaBernoulli">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">merlion.utils.conj_priors.</span></span><span class="sig-name descname"><span class="pre">BetaBernoulli</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sample</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.BetaBernoulli" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#merlion.utils.conj_priors.ScalarConjPrior" title="merlion.utils.conj_priors.ScalarConjPrior"><code class="xref py py-class docutils literal notranslate"><span class="pre">ScalarConjPrior</span></code></a></p>
<p>Beta-Bernoulli conjugate prior for binary data. We assume the model</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align*}
X &amp;\sim \mathrm{Bernoulli}(\theta) \\
\theta &amp;\sim \mathrm{Beta}(\alpha, \beta)
\end{align*}\end{split}\]</div>
<p>The update rule for data <span class="math notranslate nohighlight">\(x_1, \ldots, x_n\)</span> is</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align*}
\alpha &amp;= \alpha + \sum_{i=1}^{n} \mathbb{I}[x_i = 1] \\
\beta &amp;= \beta + \sum_{i=1}^{n} \mathbb{I}[x_i = 0]
\end{align*}\end{split}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>sample</strong> – a sample used to initialize the prior.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.BetaBernoulli.posterior">
<span class="sig-name descname"><span class="pre">posterior</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_rv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_updated</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.BetaBernoulli.posterior" title="Permalink to this definition"></a></dt>
<dd><p>The posterior distribution of x is <span class="math notranslate nohighlight">\(\mathrm{Bernoulli}(\alpha / (\alpha + \beta))\)</span>.</p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.BetaBernoulli.theta_posterior">
<span class="sig-name descname"><span class="pre">theta_posterior</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_rv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.BetaBernoulli.theta_posterior" title="Permalink to this definition"></a></dt>
<dd><p>The posterior distribution of <span class="math notranslate nohighlight">\(\theta\)</span> is <span class="math notranslate nohighlight">\(\mathrm{Beta}(\alpha, \beta)\)</span>.</p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.BetaBernoulli.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.BetaBernoulli.update" title="Permalink to this definition"></a></dt>
<dd><p>Update the conjugate prior based on new observations x.</p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.BetaBernoulli.forecast">
<span class="sig-name descname"><span class="pre">forecast</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_stamps</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.BetaBernoulli.forecast" title="Permalink to this definition"></a></dt>
<dd><p>Return a posterior predictive interval for the time stamps given.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>time_stamps</strong> – a list of time stamps</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code>[<a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a>, <a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a>]</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">(forecast,</span> <span class="pre">stderr)</span></code>, where <code class="docutils literal notranslate"><span class="pre">forecast</span></code> is the expected posterior value and <code class="docutils literal notranslate"><span class="pre">stderr</span></code> is the
standard error of that forecast.</p>
</dd>
</dl>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.NormInvGamma">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">merlion.utils.conj_priors.</span></span><span class="sig-name descname"><span class="pre">NormInvGamma</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sample</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.NormInvGamma" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#merlion.utils.conj_priors.ScalarConjPrior" title="merlion.utils.conj_priors.ScalarConjPrior"><code class="xref py py-class docutils literal notranslate"><span class="pre">ScalarConjPrior</span></code></a></p>
<p>Normal-InverseGamma conjugate prior. Following
<a class="reference external" href="https://en.wikipedia.org/wiki/Normal-inverse-gamma_distribution">Wikipedia</a> and
<a class="reference external" href="https://www.cs.ubc.ca/~murphyk/Papers/bayesGauss.pdf">Murphy (2007)</a>, we assume the model</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align*}
X &amp;\sim \mathcal{N}(\mu, \sigma^2) \\
\mu &amp;\sim \mathcal{N}(\mu_0, \sigma^2 / n) \\
\sigma^2 &amp;\sim \mathrm{InvGamma}(\alpha, \beta)
\end{align*}\end{split}\]</div>
<p>The update rule for data <span class="math notranslate nohighlight">\(x_1, \ldots, x_n\)</span> is</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align*}
\bar{x} &amp;= \frac{1}{n} \sum_{i = 1}^{n} x_i \\
\alpha &amp;= \alpha + n/2 \\
\beta &amp;= \beta + \frac{1}{2} \sum_{i = 1}^{n} (x_i - \bar{x})^2 + \frac{1}{2} (\mu_0 - \bar{x})^2 \\
\mu_0 &amp;= \frac{n_0}{n_0 + n} \mu_0 + \frac{n}{n_0 + n} \bar{x} \\
n_0 &amp;= n_0 + n
\end{align*}\end{split}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>sample</strong> – a sample used to initialize the prior.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.NormInvGamma.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.NormInvGamma.update" title="Permalink to this definition"></a></dt>
<dd><p>Update the conjugate prior based on new observations x.</p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.NormInvGamma.mu_posterior">
<span class="sig-name descname"><span class="pre">mu_posterior</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_rv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.NormInvGamma.mu_posterior" title="Permalink to this definition"></a></dt>
<dd><p>The posterior for <span class="math notranslate nohighlight">\(\mu\)</span> is <span class="math notranslate nohighlight">\(\text{Student-t}_{2\alpha}(\mu_0, \beta / (n \alpha))\)</span></p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.NormInvGamma.sigma2_posterior">
<span class="sig-name descname"><span class="pre">sigma2_posterior</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sigma2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_rv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.NormInvGamma.sigma2_posterior" title="Permalink to this definition"></a></dt>
<dd><p>The posterior for <span class="math notranslate nohighlight">\(\sigma^2\)</span> is <span class="math notranslate nohighlight">\(\text{InvGamma}(\alpha, \beta)\)</span>.</p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.NormInvGamma.posterior">
<span class="sig-name descname"><span class="pre">posterior</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_rv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_updated</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.NormInvGamma.posterior" title="Permalink to this definition"></a></dt>
<dd><p>The posterior for <span class="math notranslate nohighlight">\(x\)</span> is <span class="math notranslate nohighlight">\(\text{Student-t}_{2\alpha}(\mu_0, (n+1) \beta / (n \alpha))\)</span></p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.NormInvGamma.forecast">
<span class="sig-name descname"><span class="pre">forecast</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_stamps</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.NormInvGamma.forecast" title="Permalink to this definition"></a></dt>
<dd><p>Return a posterior predictive interval for the time stamps given.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>time_stamps</strong> – a list of time stamps</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code>[<a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a>, <a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a>]</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">(forecast,</span> <span class="pre">stderr)</span></code>, where <code class="docutils literal notranslate"><span class="pre">forecast</span></code> is the expected posterior value and <code class="docutils literal notranslate"><span class="pre">stderr</span></code> is the
standard error of that forecast.</p>
</dd>
</dl>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.MVNormInvWishart">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">merlion.utils.conj_priors.</span></span><span class="sig-name descname"><span class="pre">MVNormInvWishart</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sample</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.MVNormInvWishart" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#merlion.utils.conj_priors.ConjPrior" title="merlion.utils.conj_priors.ConjPrior"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConjPrior</span></code></a></p>
<p>Multivariate Normal-InverseWishart conjugate prior. Multivariate equivalent of Normal-InverseGamma.
Following <a class="reference external" href="https://www.cs.ubc.ca/~murphyk/Papers/bayesGauss.pdf">Murphy (2007)</a>, we assume the model</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align*}
X &amp;\sim \mathcal{N}_d(\mu, \Sigma) \\
\mu &amp;\sim \mathcal{N}_d(\mu_0, \Sigma / n) \\
\Sigma &amp;\sim \mathrm{InvWishart}_{\nu}(\Lambda)
\end{align*}\end{split}\]</div>
<p>The update rule for data <span class="math notranslate nohighlight">\(x_1, \ldots, x_n\)</span> is</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align*}
\bar{x} &amp;= \frac{1}{n} \sum_{i = 1}^{n} x_i \\
\nu &amp;= \nu + n/2 \\
\Lambda &amp;= \Lambda + \frac{n_0 n}{n_0 + n} (\mu_0 - \bar{x}) (\mu_0 - \bar{x})^T +
\sum_{i = 1}^{n} (x_i - \bar{x}) (x_i - \bar{x})^T \\
\mu_0 &amp;= \frac{n_0}{n_0 + n} \mu_0 + \frac{n}{n_0 + n} \bar{x} \\
n_0 &amp;= n_0 + n
\end{align*}\end{split}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>sample</strong> – a sample used to initialize the prior.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.MVNormInvWishart.process_time_series">
<span class="sig-name descname"><span class="pre">process_time_series</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.MVNormInvWishart.process_time_series" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">(t,</span> <span class="pre">x)</span></code>, where <code class="docutils literal notranslate"><span class="pre">t</span></code> is a normalized list of timestamps, and <code class="docutils literal notranslate"><span class="pre">x</span></code> is a <code class="docutils literal notranslate"><span class="pre">numpy</span></code> array
representing the input</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.MVNormInvWishart.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.MVNormInvWishart.update" title="Permalink to this definition"></a></dt>
<dd><p>Update the conjugate prior based on new observations x.</p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.MVNormInvWishart.mu_posterior">
<span class="sig-name descname"><span class="pre">mu_posterior</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_rv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.MVNormInvWishart.mu_posterior" title="Permalink to this definition"></a></dt>
<dd><p>The posterior for <span class="math notranslate nohighlight">\(\mu\)</span> is <span class="math notranslate nohighlight">\(\text{Student-t}_{\nu-d+1}(\mu_0, \Lambda / (n (\nu - d + 1)))\)</span></p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.MVNormInvWishart.Sigma_posterior">
<span class="sig-name descname"><span class="pre">Sigma_posterior</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sigma2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_rv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.MVNormInvWishart.Sigma_posterior" title="Permalink to this definition"></a></dt>
<dd><p>The posterior for <span class="math notranslate nohighlight">\(\Sigma\)</span> is <span class="math notranslate nohighlight">\(\text{InvWishart}_{\nu}(\Lambda^{-1})\)</span></p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.MVNormInvWishart.posterior">
<span class="sig-name descname"><span class="pre">posterior</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_rv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_updated</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.MVNormInvWishart.posterior" title="Permalink to this definition"></a></dt>
<dd><p>The posterior for <span class="math notranslate nohighlight">\(x\)</span> is <span class="math notranslate nohighlight">\(\text{Student-t}_{\nu-d+1}(\mu_0, (n + 1) \Lambda / (n (\nu - d + 1)))\)</span></p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.MVNormInvWishart.forecast">
<span class="sig-name descname"><span class="pre">forecast</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_stamps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'forecast'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.MVNormInvWishart.forecast" title="Permalink to this definition"></a></dt>
<dd><p>Return a posterior predictive interval for the time stamps given.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>time_stamps</strong> – a list of time stamps</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code>[<a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a>, <a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a>]</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">(forecast,</span> <span class="pre">stderr)</span></code>, where <code class="docutils literal notranslate"><span class="pre">forecast</span></code> is the expected posterior value and <code class="docutils literal notranslate"><span class="pre">stderr</span></code> is the
standard error of that forecast.</p>
</dd>
</dl>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.BayesianLinReg">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">merlion.utils.conj_priors.</span></span><span class="sig-name descname"><span class="pre">BayesianLinReg</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sample</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.BayesianLinReg" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#merlion.utils.conj_priors.ConjPrior" title="merlion.utils.conj_priors.ConjPrior"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConjPrior</span></code></a></p>
<p>Bayesian Ordinary Linear Regression conjugate prior, which models a univariate input as a function of time.
Following <a class="reference external" href="https://en.wikipedia.org/wiki/Bayesian_linear_regression">Wikipedia</a>, we assume the model</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align*}
x(t) &amp;\sim \mathcal{N}(m t + b, \sigma^2) \\
w &amp;\sim \mathcal{N}((m_0, b_0), \sigma^2 \Lambda_0^{-1}) \\
\sigma^2 &amp;\sim \mathrm{InvGamma}(\alpha, \beta)
\end{align*}\end{split}\]</div>
<p>Consider new data <span class="math notranslate nohighlight">\((t_1, x_1), \ldots, (t_n, x_n)\)</span>. Let <span class="math notranslate nohighlight">\(T \in \mathbb{R}^{n \times 2}\)</span> be
the matrix obtained by stacking the row vector of times with an all-ones row vector. Let
<span class="math notranslate nohighlight">\(w = (m, b) \in \mathbb{R}^{2}\)</span> be the full weight vector. Let <span class="math notranslate nohighlight">\(x \in \mathbb{R}^{n}\)</span> denote
all observed values. Then we have the update rule</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align*}
w_{OLS} &amp;= (T^T T)^{-1} T^T x \\
\Lambda_n &amp;= \Lambda_0 + T^T T \\
w_n &amp;= (\Lambda_0 + T^T T)^{-1} (\Lambda_0 w_0 + T^T T w_{OLS}) \\
\alpha_n &amp;= \alpha_0 + n / 2 \\
\beta_n &amp;= \beta_0 + \frac{1}{2}(x^T x + w_0^T \Lambda_0 w_0 - w_n^T \Lambda_n w_n)
\end{align*}\end{split}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>sample</strong> – a sample used to initialize the prior.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.BayesianLinReg.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.BayesianLinReg.update" title="Permalink to this definition"></a></dt>
<dd><p>Update the conjugate prior based on new observations x.</p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.BayesianLinReg.posterior_explicit">
<span class="sig-name descname"><span class="pre">posterior_explicit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_rv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_updated</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.BayesianLinReg.posterior_explicit" title="Permalink to this definition"></a></dt>
<dd><p>Let <span class="math notranslate nohighlight">\(\Lambda_n, \alpha_n, \beta_n\)</span> be the posterior values obtained by updating
the model on data <span class="math notranslate nohighlight">\((t_1, x_1), \ldots, (t_n, x_n)\)</span>. The predictive posterior has PDF</p>
<div class="math notranslate nohighlight">
\[\begin{align*}
P((t, x)) &amp;= \frac{1}{(2 \pi)^{-n/2}} \sqrt{\frac{\det \Lambda_0}{\det \Lambda_n}}
\frac{\beta_0^{\alpha_0}}{\beta_n^{\alpha_n}}\frac{\Gamma(\alpha_n)}{\Gamma(\alpha_0)}
\end{align*}\]</div>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.BayesianLinReg.posterior">
<span class="sig-name descname"><span class="pre">posterior</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_rv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_updated</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.BayesianLinReg.posterior" title="Permalink to this definition"></a></dt>
<dd><p>Naive computation of the posterior using Bayes Rule, i.e.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\hat{\sigma}^2 &amp;= \mathbb{E}[\sigma^2] \\
\hat{w} &amp;= \mathbb{E}[w \mid \sigma^2 = \hat{\sigma}^2] \\
p(x \mid t) &amp;= \frac{
p(w = \hat{w}, \sigma^2 = \hat{\sigma}^2)
p(x \mid t, w = \hat{w}, \sigma^2 = \hat{\sigma}^2)}{
p(w = \hat{w}, \sigma^2 = \hat{\sigma}^2 \mid x, t)}\end{split}\]</div>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.BayesianLinReg.forecast">
<span class="sig-name descname"><span class="pre">forecast</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_stamps</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.BayesianLinReg.forecast" title="Permalink to this definition"></a></dt>
<dd><p>Return a posterior predictive interval for the time stamps given.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>time_stamps</strong> – a list of time stamps</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code>[<a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a>, <a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a>]</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">(forecast,</span> <span class="pre">stderr)</span></code>, where <code class="docutils literal notranslate"><span class="pre">forecast</span></code> is the expected posterior value and <code class="docutils literal notranslate"><span class="pre">stderr</span></code> is the
standard error of that forecast.</p>
</dd>
</dl>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.BayesianMVLinReg">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">merlion.utils.conj_priors.</span></span><span class="sig-name descname"><span class="pre">BayesianMVLinReg</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sample</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.BayesianMVLinReg" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#merlion.utils.conj_priors.ConjPrior" title="merlion.utils.conj_priors.ConjPrior"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConjPrior</span></code></a></p>
<p>Bayesian multivariate linear regression conjugate prior, which models a multivariate input as a function of time.
Following <a class="reference external" href="https://en.wikipedia.org/wiki/Bayesian_multivariate_linear_regression">Wikipedia</a> and
<a class="reference external" href="https://www.jstor.org/stable/2238083">Geisser (1965)</a>, we assume the model</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align*}
X(t) &amp;\sim \mathcal{N}_{d}(m t + b, \Sigma) \\
(m, b) &amp;\sim \mathcal{N}_{2d}((m_0, b_0), \Sigma \otimes \Lambda_0^{-1}) \\
\Sigma &amp;\sim \mathrm{InvWishart}_{\nu}(V_0) \\
\end{align*}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\((m, b)\)</span> is the concatenation of the vectors <span class="math notranslate nohighlight">\(m\)</span> and <span class="math notranslate nohighlight">\(b\)</span>,
<span class="math notranslate nohighlight">\(\Lambda_0 \in \mathbb{R}^{2 \times 2}\)</span>, and <span class="math notranslate nohighlight">\(\otimes\)</span> is the Kronecker product.
Consider new data <span class="math notranslate nohighlight">\((t_1, x_1), \ldots, (t_n, x_n)\)</span>. Let <span class="math notranslate nohighlight">\(T \in \mathbb{R}^{n \times 2}\)</span> be
the matrix obtained by stacking the row vector of times with an all-ones row vector. Let
<span class="math notranslate nohighlight">\(W = [m, b]^T \in \mathbb{R}^{2 \times d}\)</span> be the full weight matrix. Let
<span class="math notranslate nohighlight">\(X \in \mathbb{R}^{n \times d}\)</span> be the matrix of observed <span class="math notranslate nohighlight">\(x\)</span> values. Then we have the update rule</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align*}
\nu_n &amp;= \nu_0 + n \\
W_n &amp;= (\Lambda_0 + T^T T)^{-1}(\Lambda_0 W_0 + T^T X) \\
V_n &amp;= V_0 + (X - TW_n)^T (X - TW_n) + (W_n - W_0)^T \Lambda_0 (W_n - W_0) \\
\Lambda_n &amp;= \Lambda_0 + T^T T \\
\end{align*}\end{split}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>sample</strong> – a sample used to initialize the prior.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.BayesianMVLinReg.process_time_series">
<span class="sig-name descname"><span class="pre">process_time_series</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.BayesianMVLinReg.process_time_series" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">(t,</span> <span class="pre">x)</span></code>, where <code class="docutils literal notranslate"><span class="pre">t</span></code> is a normalized list of timestamps, and <code class="docutils literal notranslate"><span class="pre">x</span></code> is a <code class="docutils literal notranslate"><span class="pre">numpy</span></code> array
representing the input</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.BayesianMVLinReg.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.BayesianMVLinReg.update" title="Permalink to this definition"></a></dt>
<dd><p>Update the conjugate prior based on new observations x.</p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.BayesianMVLinReg.posterior_explicit">
<span class="sig-name descname"><span class="pre">posterior_explicit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_rv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_updated</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.BayesianMVLinReg.posterior_explicit" title="Permalink to this definition"></a></dt>
<dd><p>Let <span class="math notranslate nohighlight">\(\Lambda_n, \nu_n, V_n\)</span> be the posterior values obtained by updating
the model on data <span class="math notranslate nohighlight">\((t_1, x_1), \ldots, (t_n, x_n)\)</span>. The predictive posterior has PDF</p>
<div class="math notranslate nohighlight">
\[\begin{align*}
P((t, x)) &amp;= \frac{1}{(2 \pi)^{-nd/2}} \sqrt{\frac{\det \Lambda_0}{\det \Lambda_n}}
\frac{\det(V_0/2)^{\nu_0/2}}{\det(V_n/2)^{\nu_n/2}}\frac{\Gamma_d(\nu_n/2)}{\Gamma_d(\nu_0 / 2)}
\end{align*}\]</div>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.BayesianMVLinReg.posterior">
<span class="sig-name descname"><span class="pre">posterior</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_rv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_updated</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.BayesianMVLinReg.posterior" title="Permalink to this definition"></a></dt>
<dd><p>Naive computation of the posterior using Bayes Rule, i.e.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\hat{\Sigma} &amp;= \mathbb{E}[\Sigma] \\
\hat{W} &amp;= \mathbb{E}[W \mid \Sigma = \hat{\Sigma}] \\
p(X \mid t) &amp;= \frac{
p(W = \hat{W}, \Sigma = \hat{\Sigma})
p(X \mid t, W = \hat{W}, \Sigma = \hat{\Sigma})}{
p(W = \hat{W}, \Sigma = \hat{\Sigma} \mid x, t)}\end{split}\]</div>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.BayesianMVLinReg.forecast">
<span class="sig-name descname"><span class="pre">forecast</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_stamps</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.BayesianMVLinReg.forecast" title="Permalink to this definition"></a></dt>
<dd><p>Return a posterior predictive interval for the time stamps given.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>time_stamps</strong> – a list of time stamps</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code>[<a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a>, <a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a>]</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">(forecast,</span> <span class="pre">stderr)</span></code>, where <code class="docutils literal notranslate"><span class="pre">forecast</span></code> is the expected posterior value and <code class="docutils literal notranslate"><span class="pre">stderr</span></code> is the
standard error of that forecast.</p>
</dd>
</dl>
</dd></dl>
</dd></dl>
</section>
<section id="module-merlion.utils.istat">
<span id="merlion-utils-istat-module"></span><h2>merlion.utils.istat module<a class="headerlink" href="#module-merlion.utils.istat" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="merlion.utils.istat.IStat">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">merlion.utils.istat.</span></span><span class="sig-name descname"><span class="pre">IStat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.istat.IStat" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>An abstract base class for computing various statistics incrementally,
with emphasis on recency-weighted variants.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>value</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]) – Initial value of the statistic. Defaults to None.</p></li>
<li><p><strong>n</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Initial sample size. Defaults to 0.</p></li>
</ul>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="merlion.utils.istat.IStat.n">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">n</span></span><a class="headerlink" href="#merlion.utils.istat.IStat.n" title="Permalink to this definition"></a></dt>
<dd></dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="merlion.utils.istat.IStat.value">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">value</span></span><a class="headerlink" href="#merlion.utils.istat.IStat.value" title="Permalink to this definition"></a></dt>
<dd></dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.istat.IStat.add">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">add</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.istat.IStat.add" title="Permalink to this definition"></a></dt>
<dd><p>Add a new value to update the statistic.
:param x: new value to add to the sample.</p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.istat.IStat.drop">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">drop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.istat.IStat.drop" title="Permalink to this definition"></a></dt>
<dd><p>Drop a value to update the statistic.
:param x: value to drop from the sample.</p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.istat.IStat.add_batch">
<span class="sig-name descname"><span class="pre">add_batch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">batch</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.istat.IStat.add_batch" title="Permalink to this definition"></a></dt>
<dd><p>Add a batch of new values to update the statistic.
:type batch: <code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]
:param batch: new values to add to the sample.</p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.istat.IStat.drop_batch">
<span class="sig-name descname"><span class="pre">drop_batch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">batch</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.istat.IStat.drop_batch" title="Permalink to this definition"></a></dt>
<dd><p>Drop a batch of new values to update the statistic.
:type batch: <code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]
:param batch: new values to add to the sample.</p>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="merlion.utils.istat.Mean">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">merlion.utils.istat.</span></span><span class="sig-name descname"><span class="pre">Mean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.istat.Mean" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#merlion.utils.istat.IStat" title="merlion.utils.istat.IStat"><code class="xref py py-class docutils literal notranslate"><span class="pre">IStat</span></code></a></p>
<p>Class for incrementally computing the mean of a series of numbers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>value</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]) – Initial value of the statistic. Defaults to None.</p></li>
<li><p><strong>n</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Initial sample size. Defaults to 0.</p></li>
</ul>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="merlion.utils.istat.Mean.value">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">value</span></span><a class="headerlink" href="#merlion.utils.istat.Mean.value" title="Permalink to this definition"></a></dt>
<dd></dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.istat.Mean.add">
<span class="sig-name descname"><span class="pre">add</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.istat.Mean.add" title="Permalink to this definition"></a></dt>
<dd><p>Add a new value to update the statistic.
:param x: new value to add to the sample.</p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.istat.Mean.drop">
<span class="sig-name descname"><span class="pre">drop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.istat.Mean.drop" title="Permalink to this definition"></a></dt>
<dd><p>Drop a value to update the statistic.
:param x: value to drop from the sample.</p>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="merlion.utils.istat.Variance">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">merlion.utils.istat.</span></span><span class="sig-name descname"><span class="pre">Variance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ex_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ex2_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ddof</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.istat.Variance" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#merlion.utils.istat.IStat" title="merlion.utils.istat.IStat"><code class="xref py py-class docutils literal notranslate"><span class="pre">IStat</span></code></a></p>
<p>Class for incrementally computing the variance of a series of numbers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ex_value</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]) – Initial value of the first moment (mean).</p></li>
<li><p><strong>ex2_value</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]) – Initial value of the second moment.</p></li>
<li><p><strong>n</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Initial sample size.</p></li>
<li><p><strong>ddof</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – The delta degrees of freedom to use when correcting
the estimate of the variance.</p></li>
</ul>
</dd>
</dl>
<div class="math notranslate nohighlight">
\[\text{Var}(x_i) = \text{E}(x_i^2) - \text{E}(x_i)^2\]</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="merlion.utils.istat.Variance.mean_class">
<span class="sig-name descname"><span class="pre">mean_class</span></span><a class="headerlink" href="#merlion.utils.istat.Variance.mean_class" title="Permalink to this definition"></a></dt>
<dd><p>alias of <a class="reference internal" href="#merlion.utils.istat.Mean" title="merlion.utils.istat.Mean"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mean</span></code></a></p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.istat.Variance.add">
<span class="sig-name descname"><span class="pre">add</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.istat.Variance.add" title="Permalink to this definition"></a></dt>
<dd><p>Add a new value to update the statistic.
:param x: new value to add to the sample.</p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.istat.Variance.drop">
<span class="sig-name descname"><span class="pre">drop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.istat.Variance.drop" title="Permalink to this definition"></a></dt>
<dd><p>Drop a value to update the statistic.
:param x: value to drop from the sample.</p>
</dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="merlion.utils.istat.Variance.true_value">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">true_value</span></span><a class="headerlink" href="#merlion.utils.istat.Variance.true_value" title="Permalink to this definition"></a></dt>
<dd></dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="merlion.utils.istat.Variance.corrected_value">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">corrected_value</span></span><a class="headerlink" href="#merlion.utils.istat.Variance.corrected_value" title="Permalink to this definition"></a></dt>
<dd></dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="merlion.utils.istat.Variance.value">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">value</span></span><a class="headerlink" href="#merlion.utils.istat.Variance.value" title="Permalink to this definition"></a></dt>
<dd></dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="merlion.utils.istat.Variance.sd">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">sd</span></span><a class="headerlink" href="#merlion.utils.istat.Variance.sd" title="Permalink to this definition"></a></dt>
<dd></dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="merlion.utils.istat.Variance.se">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">se</span></span><a class="headerlink" href="#merlion.utils.istat.Variance.se" title="Permalink to this definition"></a></dt>
<dd></dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="merlion.utils.istat.ExponentialMovingAverage">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">merlion.utils.istat.</span></span><span class="sig-name descname"><span class="pre">ExponentialMovingAverage</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">recency_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.istat.ExponentialMovingAverage" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#merlion.utils.istat.Mean" title="merlion.utils.istat.Mean"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mean</span></code></a></p>
<p>Class for incrementally computing the exponential moving average of a series of numbers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>recency_weight</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Recency weight to use when updating the
exponential moving average.</p>
</dd>
</dl>
<p>Letting <code class="docutils literal notranslate"><span class="pre">w</span></code> be the recency weight,</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align*}
\text{EMA}_w(x_0) &amp; = x_0 \\
\text{EMA}_w(x_t) &amp; = w \cdot x_t + (1-w) \cdot \text{EMA}_w(x_{t-1})
\end{align*}\end{split}\]</div>
<dl class="py property">
<dt class="sig sig-object py" id="merlion.utils.istat.ExponentialMovingAverage.recency_weight">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">recency_weight</span></span><a class="headerlink" href="#merlion.utils.istat.ExponentialMovingAverage.recency_weight" title="Permalink to this definition"></a></dt>
<dd></dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="merlion.utils.istat.ExponentialMovingAverage.value">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">value</span></span><a class="headerlink" href="#merlion.utils.istat.ExponentialMovingAverage.value" title="Permalink to this definition"></a></dt>
<dd></dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.istat.ExponentialMovingAverage.drop">
<span class="sig-name descname"><span class="pre">drop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.istat.ExponentialMovingAverage.drop" title="Permalink to this definition"></a></dt>
<dd><p>Exponential Moving Average does not support dropping values</p>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="merlion.utils.istat.RecencyWeightedVariance">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">merlion.utils.istat.</span></span><span class="sig-name descname"><span class="pre">RecencyWeightedVariance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">recency_weight</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.istat.RecencyWeightedVariance" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#merlion.utils.istat.Variance" title="merlion.utils.istat.Variance"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variance</span></code></a></p>
<p>Class for incrementally computing the recency-weighted variance of a series of numbers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>recency_weight</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Recency weight to use when updating the
recency weighted variance.</p>
</dd>
</dl>
<p>Letting <code class="docutils literal notranslate"><span class="pre">w</span></code> be the recency weight,</p>
<div class="math notranslate nohighlight">
\[\text{RWV}_w(x_t) = \text{EMA}_w({x^2_t}) - \text{EMA}_w(x_t)^2\]</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="merlion.utils.istat.RecencyWeightedVariance.mean_class">
<span class="sig-name descname"><span class="pre">mean_class</span></span><a class="headerlink" href="#merlion.utils.istat.RecencyWeightedVariance.mean_class" title="Permalink to this definition"></a></dt>
<dd><p>alias of <a class="reference internal" href="#merlion.utils.istat.ExponentialMovingAverage" title="merlion.utils.istat.ExponentialMovingAverage"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExponentialMovingAverage</span></code></a></p>
</dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="merlion.utils.istat.RecencyWeightedVariance.recency_weight">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">recency_weight</span></span><a class="headerlink" href="#merlion.utils.istat.RecencyWeightedVariance.recency_weight" title="Permalink to this definition"></a></dt>
<dd></dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.istat.RecencyWeightedVariance.drop">
<span class="sig-name descname"><span class="pre">drop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.istat.RecencyWeightedVariance.drop" title="Permalink to this definition"></a></dt>
<dd><p>Recency Weighted Variance does not support dropping values</p>
</dd></dl>
</dd></dl>
</section>
<section id="module-merlion.utils.misc">
<span id="merlion-utils-misc-module"></span><h2>merlion.utils.misc module<a class="headerlink" href="#module-merlion.utils.misc" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="merlion.utils.misc.AutodocABCMeta">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">merlion.utils.misc.</span></span><span class="sig-name descname"><span class="pre">AutodocABCMeta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bases</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cls_dict</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.misc.AutodocABCMeta" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">ABCMeta</span></code></p>
<p>Metaclass used to ensure that inherited members of an abstract base class
also inherit docstrings for inherited methods.</p>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="merlion.utils.misc.ModelConfigMeta">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">merlion.utils.misc.</span></span><span class="sig-name descname"><span class="pre">ModelConfigMeta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bases</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cls_dict</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.misc.ModelConfigMeta" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></p>
<p>Metaclass used to ensure that the function signatures for model <a class="reference internal" href="merlion.models.html#merlion.models.base.Config" title="merlion.models.base.Config"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Config</span></code></a> initializers contain all
relevant parameters, including those specified in the superclass. Also update docstrings accordingly.</p>
<p>For example, the only parameter of the base class <a class="reference internal" href="merlion.models.html#merlion.models.base.Config" title="merlion.models.base.Config"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Config</span></code></a> is <code class="docutils literal notranslate"><span class="pre">transform</span></code>. <a class="reference internal" href="merlion.models.forecast.html#merlion.models.forecast.base.ForecasterConfig" title="merlion.models.forecast.base.ForecasterConfig"><code class="xref any py py-class docutils literal notranslate"><span class="pre">ForecasterConfig</span></code></a> adds the
parameters <code class="docutils literal notranslate"><span class="pre">max_forecast_steps</span></code> and <code class="docutils literal notranslate"><span class="pre">target_seq_index</span></code>. Because <a class="reference internal" href="merlion.models.html#merlion.models.base.Config" title="merlion.models.base.Config"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Config</span></code></a> inherits from this metaclass,
we can declare</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ForecasterConfig</span><span class="p">(</span><span class="n">Config</span><span class="p">):</span>

<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_forecast_steps</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">target_seq_index</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>and have the function signature for <a class="reference internal" href="merlion.models.forecast.html#merlion.models.forecast.base.ForecasterConfig" title="merlion.models.forecast.base.ForecasterConfig"><code class="xref any py py-class docutils literal notranslate"><span class="pre">ForecasterConfig</span></code></a>’s initializer include the parameter <code class="docutils literal notranslate"><span class="pre">transform</span></code>,
even though we never declared it explicitly. Additionally, the docstring for <code class="docutils literal notranslate"><span class="pre">transform</span></code> is inherited
from the base class.</p>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="merlion.utils.misc.combine_signatures">
<span class="sig-prename descclassname"><span class="pre">merlion.utils.misc.</span></span><span class="sig-name descname"><span class="pre">combine_signatures</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sig1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sig2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.misc.combine_signatures" title="Permalink to this definition"></a></dt>
<dd><p>Utility function which combines the signatures of two functions.</p>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="merlion.utils.misc.parse_init_docstring">
<span class="sig-prename descclassname"><span class="pre">merlion.utils.misc.</span></span><span class="sig-name descname"><span class="pre">parse_init_docstring</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">docstring</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.misc.parse_init_docstring" title="Permalink to this definition"></a></dt>
<dd></dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="merlion.utils.misc.ValIterOrderedDict">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">merlion.utils.misc.</span></span><span class="sig-name descname"><span class="pre">ValIterOrderedDict</span></span><a class="headerlink" href="#merlion.utils.misc.ValIterOrderedDict" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">OrderedDict</span></code></p>
<p>OrderedDict whose iterator goes over self.values() instead of self.keys().</p>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="merlion.utils.misc.dynamic_import">
<span class="sig-prename descclassname"><span class="pre">merlion.utils.misc.</span></span><span class="sig-name descname"><span class="pre">dynamic_import</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">import_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alias</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.misc.dynamic_import" title="Permalink to this definition"></a></dt>
<dd><p>Dynamically import a member from the specified module.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>import_path</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – syntax ‘module_name:member_name’,
e.g. ‘merlion.transform.normalize:PowerTransform’</p></li>
<li><p><strong>alias</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code>]) – dict which maps shortcuts for the registered classes, to their
full import paths.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>imported class</p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="merlion.utils.misc.initializer">
<span class="sig-prename descclassname"><span class="pre">merlion.utils.misc.</span></span><span class="sig-name descname"><span class="pre">initializer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.misc.initializer" title="Permalink to this definition"></a></dt>
<dd><p>Decorator for the __init__ method.
Automatically assigns the parameters.</p>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="merlion.utils.misc.ProgressBar">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">merlion.utils.misc.</span></span><span class="sig-name descname"><span class="pre">ProgressBar</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">total</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">40</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">decimals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fill</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'█'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.misc.ProgressBar" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>total</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – total iterations</p></li>
<li><p><strong>length</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – character length of bar</p></li>
<li><p><strong>decimals</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – positive number of decimals in percent complete</p></li>
<li><p><strong>fill</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – bar fill character</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.misc.ProgressBar.print">
<span class="sig-name descname"><span class="pre">print</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iteration</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prefix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">suffix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.misc.ProgressBar.print" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iteration</strong> – current iteration</p></li>
<li><p><strong>prefix</strong> – prefix string</p></li>
<li><p><strong>suffix</strong> – suffix string</p></li>
<li><p><strong>end</strong> – end character (e.g. <code class="docutils literal notranslate"><span class="pre">"\r"</span></code>, <code class="docutils literal notranslate"><span class="pre">"\r\n"</span></code>)</p></li>
</ul>
</dd>
</dl>
</dd></dl>
</dd></dl>
</section>
<section id="module-merlion.utils.resample">
<span id="merlion-utils-resample-module"></span><h2>merlion.utils.resample module<a class="headerlink" href="#module-merlion.utils.resample" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="merlion.utils.resample.AlignPolicy">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">merlion.utils.resample.</span></span><span class="sig-name descname"><span class="pre">AlignPolicy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.resample.AlignPolicy" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Enum</span></code></p>
<p>Policies for aligning multiple univariate time series.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="merlion.utils.resample.AlignPolicy.OuterJoin">
<span class="sig-name descname"><span class="pre">OuterJoin</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">0</span></em><a class="headerlink" href="#merlion.utils.resample.AlignPolicy.OuterJoin" title="Permalink to this definition"></a></dt>
<dd></dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="merlion.utils.resample.AlignPolicy.InnerJoin">
<span class="sig-name descname"><span class="pre">InnerJoin</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">1</span></em><a class="headerlink" href="#merlion.utils.resample.AlignPolicy.InnerJoin" title="Permalink to this definition"></a></dt>
<dd></dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="merlion.utils.resample.AlignPolicy.FixedReference">
<span class="sig-name descname"><span class="pre">FixedReference</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">2</span></em><a class="headerlink" href="#merlion.utils.resample.AlignPolicy.FixedReference" title="Permalink to this definition"></a></dt>
<dd></dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="merlion.utils.resample.AlignPolicy.FixedGranularity">
<span class="sig-name descname"><span class="pre">FixedGranularity</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">3</span></em><a class="headerlink" href="#merlion.utils.resample.AlignPolicy.FixedGranularity" title="Permalink to this definition"></a></dt>
<dd></dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="merlion.utils.resample.AggregationPolicy">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">merlion.utils.resample.</span></span><span class="sig-name descname"><span class="pre">AggregationPolicy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.resample.AggregationPolicy" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Enum</span></code></p>
<p>Aggregation policies. Values are partial functions for
pandas.core.resample.Resampler methods.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="merlion.utils.resample.AggregationPolicy.Mean">
<span class="sig-name descname"><span class="pre">Mean</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">functools.partial(&lt;function</span> <span class="pre">AggregationPolicy.&lt;lambda&gt;&gt;)</span></em><a class="headerlink" href="#merlion.utils.resample.AggregationPolicy.Mean" title="Permalink to this definition"></a></dt>
<dd></dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="merlion.utils.resample.AggregationPolicy.Sum">
<span class="sig-name descname"><span class="pre">Sum</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">functools.partial(&lt;function</span> <span class="pre">AggregationPolicy.&lt;lambda&gt;&gt;)</span></em><a class="headerlink" href="#merlion.utils.resample.AggregationPolicy.Sum" title="Permalink to this definition"></a></dt>
<dd></dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="merlion.utils.resample.AggregationPolicy.Median">
<span class="sig-name descname"><span class="pre">Median</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">functools.partial(&lt;function</span> <span class="pre">AggregationPolicy.&lt;lambda&gt;&gt;)</span></em><a class="headerlink" href="#merlion.utils.resample.AggregationPolicy.Median" title="Permalink to this definition"></a></dt>
<dd></dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="merlion.utils.resample.AggregationPolicy.First">
<span class="sig-name descname"><span class="pre">First</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">functools.partial(&lt;function</span> <span class="pre">AggregationPolicy.&lt;lambda&gt;&gt;)</span></em><a class="headerlink" href="#merlion.utils.resample.AggregationPolicy.First" title="Permalink to this definition"></a></dt>
<dd></dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="merlion.utils.resample.AggregationPolicy.Last">
<span class="sig-name descname"><span class="pre">Last</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">functools.partial(&lt;function</span> <span class="pre">AggregationPolicy.&lt;lambda&gt;&gt;)</span></em><a class="headerlink" href="#merlion.utils.resample.AggregationPolicy.Last" title="Permalink to this definition"></a></dt>
<dd></dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="merlion.utils.resample.AggregationPolicy.Min">
<span class="sig-name descname"><span class="pre">Min</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">functools.partial(&lt;function</span> <span class="pre">AggregationPolicy.&lt;lambda&gt;&gt;)</span></em><a class="headerlink" href="#merlion.utils.resample.AggregationPolicy.Min" title="Permalink to this definition"></a></dt>
<dd></dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="merlion.utils.resample.AggregationPolicy.Max">
<span class="sig-name descname"><span class="pre">Max</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">functools.partial(&lt;function</span> <span class="pre">AggregationPolicy.&lt;lambda&gt;&gt;)</span></em><a class="headerlink" href="#merlion.utils.resample.AggregationPolicy.Max" title="Permalink to this definition"></a></dt>
<dd></dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="merlion.utils.resample.MissingValuePolicy">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">merlion.utils.resample.</span></span><span class="sig-name descname"><span class="pre">MissingValuePolicy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.resample.MissingValuePolicy" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Enum</span></code></p>
<p>Missing value imputation policies. Values are partial functions for
<code class="docutils literal notranslate"><span class="pre">pd.Series</span></code> methods.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="merlion.utils.resample.MissingValuePolicy.FFill">
<span class="sig-name descname"><span class="pre">FFill</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">functools.partial(&lt;function</span> <span class="pre">MissingValuePolicy.&lt;lambda&gt;&gt;)</span></em><a class="headerlink" href="#merlion.utils.resample.MissingValuePolicy.FFill" title="Permalink to this definition"></a></dt>
<dd><p>Fill gap with the first value before the gap.</p>
</dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="merlion.utils.resample.MissingValuePolicy.BFill">
<span class="sig-name descname"><span class="pre">BFill</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">functools.partial(&lt;function</span> <span class="pre">MissingValuePolicy.&lt;lambda&gt;&gt;)</span></em><a class="headerlink" href="#merlion.utils.resample.MissingValuePolicy.BFill" title="Permalink to this definition"></a></dt>
<dd><p>Fill gap with the first value after the gap.</p>
</dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="merlion.utils.resample.MissingValuePolicy.Nearest">
<span class="sig-name descname"><span class="pre">Nearest</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">functools.partial(&lt;function</span> <span class="pre">MissingValuePolicy.&lt;lambda&gt;&gt;,</span> <span class="pre">method='nearest')</span></em><a class="headerlink" href="#merlion.utils.resample.MissingValuePolicy.Nearest" title="Permalink to this definition"></a></dt>
<dd><p>Replace missing value with the value closest to it.</p>
</dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="merlion.utils.resample.MissingValuePolicy.Interpolate">
<span class="sig-name descname"><span class="pre">Interpolate</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">functools.partial(&lt;function</span> <span class="pre">MissingValuePolicy.&lt;lambda&gt;&gt;,</span> <span class="pre">method='time')</span></em><a class="headerlink" href="#merlion.utils.resample.MissingValuePolicy.Interpolate" title="Permalink to this definition"></a></dt>
<dd><p>Fill in missing values by linear interpolation.</p>
</dd></dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="merlion.utils.resample.to_pd_datetime">
<span class="sig-prename descclassname"><span class="pre">merlion.utils.resample.</span></span><span class="sig-name descname"><span class="pre">to_pd_datetime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">timestamp</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.resample.to_pd_datetime" title="Permalink to this definition"></a></dt>
<dd><p>Converts a timestamp (or list/iterable of timestamps) to pandas Datetime,
truncated at the millisecond.</p>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="merlion.utils.resample.to_timestamp">
<span class="sig-prename descclassname"><span class="pre">merlion.utils.resample.</span></span><span class="sig-name descname"><span class="pre">to_timestamp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.resample.to_timestamp" title="Permalink to this definition"></a></dt>
<dd><p>Converts a datetime to a Unix timestamp.</p>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="merlion.utils.resample.granularity_str_to_seconds">
<span class="sig-prename descclassname"><span class="pre">merlion.utils.resample.</span></span><span class="sig-name descname"><span class="pre">granularity_str_to_seconds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">granularity</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.resample.granularity_str_to_seconds" title="Permalink to this definition"></a></dt>
<dd><p>Converts a string/float/int granularity (representing a timedelta) to the
number of seconds it represents, truncated at the millisecond.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]</p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="merlion.utils.resample.get_gcd_timedelta">
<span class="sig-prename descclassname"><span class="pre">merlion.utils.resample.</span></span><span class="sig-name descname"><span class="pre">get_gcd_timedelta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">time_stamp_lists</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.resample.get_gcd_timedelta" title="Permalink to this definition"></a></dt>
<dd><p>Calculates all timedeltas present in any of the lists of time stamps given,
and returns the GCD of all these timedeltas (up to units of milliseconds).</p>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="merlion.utils.resample.infer_granularity">
<span class="sig-prename descclassname"><span class="pre">merlion.utils.resample.</span></span><span class="sig-name descname"><span class="pre">infer_granularity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_stamps</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.resample.infer_granularity" title="Permalink to this definition"></a></dt>
<dd><p>Infers the granularity of a list of time stamps</p>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="merlion.utils.resample.reindex_df">
<span class="sig-prename descclassname"><span class="pre">merlion.utils.resample.</span></span><span class="sig-name descname"><span class="pre">reindex_df</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">df</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reference</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">missing_value_policy</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.resample.reindex_df" title="Permalink to this definition"></a></dt>
<dd><p>Reindexes a Datetime-indexed dataframe <code class="docutils literal notranslate"><span class="pre">df</span></code> to have the same time stamps
as a reference sequence of timestamps. Imputes missing values with the given
<a class="reference internal" href="#merlion.utils.resample.MissingValuePolicy" title="merlion.utils.resample.MissingValuePolicy"><code class="xref any py py-class docutils literal notranslate"><span class="pre">MissingValuePolicy</span></code></a>.</p>
</dd></dl>
</section>
<section id="module-merlion.utils.time_series">
<span id="merlion-utils-time-series-module"></span><h2>merlion.utils.time_series module<a class="headerlink" href="#module-merlion.utils.time_series" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="merlion.utils.time_series.UnivariateTimeSeries">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">merlion.utils.time_series.</span></span><span class="sig-name descname"><span class="pre">UnivariateTimeSeries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_stamps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'1h'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.time_series.UnivariateTimeSeries" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code></p>
<p>Please read the <a class="reference internal" href="examples/TimeSeries.html"><span class="doc">tutorial</span></a> before reading this API doc.
This class is a time-indexed <code class="docutils literal notranslate"><span class="pre">pd.Series</span></code> which represents a univariate
time series. For the most part, it supports all the same features as
<code class="docutils literal notranslate"><span class="pre">pd.Series</span></code>, with the following key differences to iteration and indexing:</p>
<ol class="arabic">
<li><p>Iterating over a <a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries" title="merlion.utils.time_series.UnivariateTimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">UnivariateTimeSeries</span></code></a> is implemented as</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">univariate</span><span class="p">:</span>
    <span class="c1"># do stuff...</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">timestamp</span></code> is a Unix timestamp, and <code class="docutils literal notranslate"><span class="pre">value</span></code> is the
corresponding time series value.</p>
</li>
<li><p>Integer index: <code class="docutils literal notranslate"><span class="pre">u[i]</span></code> yields the tuple <code class="docutils literal notranslate"><span class="pre">(u.time_stamps[i],</span> <span class="pre">u.values[i])</span></code></p></li>
<li><p>Slice index: <code class="docutils literal notranslate"><span class="pre">u[i:j:k]</span></code> yields a new
<code class="docutils literal notranslate"><span class="pre">UnivariateTimeSeries(u.time_stamps[i:j:k],</span> <span class="pre">u.values[i:j:k])</span></code></p></li>
</ol>
<p>The class also supports the following additional features:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">univariate.time_stamps</span></code> returns the list of Unix timestamps, and
<code class="docutils literal notranslate"><span class="pre">univariate.values</span></code> returns the list of the time series values. You
may access the <code class="docutils literal notranslate"><span class="pre">pd.DatetimeIndex</span></code> directly with <code class="docutils literal notranslate"><span class="pre">univariate.index</span></code>
(or its <code class="docutils literal notranslate"><span class="pre">np.ndarray</span></code> representation with <code class="docutils literal notranslate"><span class="pre">univariate.np_time_stamps</span></code>),
and the <code class="docutils literal notranslate"><span class="pre">np.ndarray</span></code> of values with <code class="docutils literal notranslate"><span class="pre">univariate.np_values</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">univariate.concat(other)</span></code> will concatenate the UnivariateTimeSeries
<code class="docutils literal notranslate"><span class="pre">other</span></code> to the right end of <code class="docutils literal notranslate"><span class="pre">univariate</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">left,</span> <span class="pre">right</span> <span class="pre">=</span> <span class="pre">univariate.bisect(t)</span></code> will split the univariate at the
given timestamp <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">window</span> <span class="pre">=</span> <span class="pre">univariate.window(t0,</span> <span class="pre">tf)</span></code> will return the subset of the time
series occurring between timestamps <code class="docutils literal notranslate"><span class="pre">t0</span></code> (inclusive) and <code class="docutils literal notranslate"><span class="pre">tf</span></code>
(non-inclusive)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">series</span> <span class="pre">=</span> <span class="pre">univariate.to_pd()</span></code> will convert the <a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries" title="merlion.utils.time_series.UnivariateTimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">UnivariateTimeSeries</span></code></a>
into a regular <code class="docutils literal notranslate"><span class="pre">pd.Series</span></code> (for compatibility).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">univariate</span> <span class="pre">=</span> <span class="pre">UnivariateTimeSeries.from_pd(series)</span></code> uses a time-indexed
<code class="docutils literal notranslate"><span class="pre">pd.Series</span></code> to create a <a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries" title="merlion.utils.time_series.UnivariateTimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">UnivariateTimeSeries</span></code></a> object directly.</p></li>
</ol>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.time_series.UnivariateTimeSeries.__getitem__">
<span class="sig-name descname"><span class="pre">__getitem__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.time_series.UnivariateTimeSeries.__getitem__" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>i</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">slice</span></code>]) – integer index or slice</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>Union[Tuple[float, float], <a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries" title="merlion.utils.time_series.UnivariateTimeSeries">UnivariateTimeSeries</a>]</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">(self.time_stamps[i],</span> <span class="pre">self.values[i])</span></code> if <code class="docutils literal notranslate"><span class="pre">i</span></code> is
an integer. <code class="docutils literal notranslate"><span class="pre">UnivariateTimeSeries(self.time_series[i],</span> <span class="pre">self.values[i])</span></code>
if <code class="docutils literal notranslate"><span class="pre">i</span></code> is a slice.</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.time_series.UnivariateTimeSeries.__iter__">
<span class="sig-name descname"><span class="pre">__iter__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.time_series.UnivariateTimeSeries.__iter__" title="Permalink to this definition"></a></dt>
<dd><p>The i’th item in the iterator is the tuple
<code class="docutils literal notranslate"><span class="pre">(self.time_stamps[i],</span> <span class="pre">self.values[i])</span></code>.</p>
</dd></dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>time_stamps</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code>[<code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]]]) – a sequence of Unix timestamps. You may specify
<code class="docutils literal notranslate"><span class="pre">None</span></code> if you only have <code class="docutils literal notranslate"><span class="pre">values</span></code> with no specific time stamps.</p></li>
<li><p><strong>values</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]) – a sequence of univariate values, where <code class="docutils literal notranslate"><span class="pre">values[i]</span></code>
occurs at time <code class="docutils literal notranslate"><span class="pre">time_stamps[i]</span></code></p></li>
<li><p><strong>name</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]) – the name of the univariate time series</p></li>
<li><p><strong>freq</strong> – if <code class="docutils literal notranslate"><span class="pre">time_stamps</span></code> is not provided, the univariate is
assumed to be sampled at frequency <code class="docutils literal notranslate"><span class="pre">freq</span></code>. <code class="docutils literal notranslate"><span class="pre">freq</span></code> may be a
string (e.g. <code class="docutils literal notranslate"><span class="pre">"1h"</span></code>), timedelta, or <code class="docutils literal notranslate"><span class="pre">int</span></code>/<code class="docutils literal notranslate"><span class="pre">float</span></code> (in units
of seconds).</p></li>
</ul>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="merlion.utils.time_series.UnivariateTimeSeries.np_time_stamps">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">np_time_stamps</span></span><a class="headerlink" href="#merlion.utils.time_series.UnivariateTimeSeries.np_time_stamps" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the <code class="docutils literal notranslate"><span class="pre">numpy</span></code> representation of this time series’s Unix timestamps</p>
</dd>
</dl>
</dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="merlion.utils.time_series.UnivariateTimeSeries.np_values">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">np_values</span></span><a class="headerlink" href="#merlion.utils.time_series.UnivariateTimeSeries.np_values" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the <code class="docutils literal notranslate"><span class="pre">numpy</span></code> representation of this time series’s values</p>
</dd>
</dl>
</dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="merlion.utils.time_series.UnivariateTimeSeries.time_stamps">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">time_stamps</span></span><a class="headerlink" href="#merlion.utils.time_series.UnivariateTimeSeries.time_stamps" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>List[float]</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the list of Unix timestamps for the time series</p>
</dd>
</dl>
</dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="merlion.utils.time_series.UnivariateTimeSeries.values">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">values</span></span><a class="headerlink" href="#merlion.utils.time_series.UnivariateTimeSeries.values" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>List[float]</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the list of values for the time series.</p>
</dd>
</dl>
</dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="merlion.utils.time_series.UnivariateTimeSeries.t0">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">t0</span></span><a class="headerlink" href="#merlion.utils.time_series.UnivariateTimeSeries.t0" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the first timestamp in the univariate time series.</p>
</dd>
</dl>
</dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="merlion.utils.time_series.UnivariateTimeSeries.tf">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">tf</span></span><a class="headerlink" href="#merlion.utils.time_series.UnivariateTimeSeries.tf" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the final timestamp in the univariate time series.</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.time_series.UnivariateTimeSeries.is_empty">
<span class="sig-name descname"><span class="pre">is_empty</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.time_series.UnivariateTimeSeries.is_empty" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if the univariate is empty, False if not.</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.time_series.UnivariateTimeSeries.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">deep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.time_series.UnivariateTimeSeries.copy" title="Permalink to this definition"></a></dt>
<dd><p>Copies the <a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries" title="merlion.utils.time_series.UnivariateTimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">UnivariateTimeSeries</span></code></a>. Simply a wrapper around the
<code class="docutils literal notranslate"><span class="pre">pd.Series.copy()</span></code> method.</p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.time_series.UnivariateTimeSeries.concat">
<span class="sig-name descname"><span class="pre">concat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.time_series.UnivariateTimeSeries.concat" title="Permalink to this definition"></a></dt>
<dd><p>Concatenates the <a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries" title="merlion.utils.time_series.UnivariateTimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">UnivariateTimeSeries</span></code></a> <code class="docutils literal notranslate"><span class="pre">other</span></code> to the right of this one.
:param UnivariateTimeSeries other: another <a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries" title="merlion.utils.time_series.UnivariateTimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">UnivariateTimeSeries</span></code></a>
:rtype: UnivariateTimeSeries
:return: concatenated univariate time series</p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.time_series.UnivariateTimeSeries.bisect">
<span class="sig-name descname"><span class="pre">bisect</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t_in_left</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.time_series.UnivariateTimeSeries.bisect" title="Permalink to this definition"></a></dt>
<dd><p>Splits the time series at the point where the given timestamp occurs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – a Unix timestamp or datetime object. Everything before time
<code class="docutils literal notranslate"><span class="pre">t</span></code> is in the left split, and everything after time <code class="docutils literal notranslate"><span class="pre">t</span></code> is in
the right split.</p></li>
<li><p><strong>t_in_left</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – if <code class="docutils literal notranslate"><span class="pre">True</span></code>, <code class="docutils literal notranslate"><span class="pre">t</span></code> is in the left split. Otherwise,
<code class="docutils literal notranslate"><span class="pre">t</span></code> is in the right split.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>Tuple[<a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries" title="merlion.utils.time_series.UnivariateTimeSeries">UnivariateTimeSeries</a>, <a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries" title="merlion.utils.time_series.UnivariateTimeSeries">UnivariateTimeSeries</a>]</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the left and right splits of the time series.</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.time_series.UnivariateTimeSeries.window">
<span class="sig-name descname"><span class="pre">window</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_tf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.time_series.UnivariateTimeSeries.window" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t0</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – The timestamp/datetime at the start of the window (inclusive)</p></li>
<li><p><strong>tf</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – The timestamp/datetime at the end of the window (inclusive
if <code class="docutils literal notranslate"><span class="pre">include_tf</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, non-inclusive otherwise)</p></li>
<li><p><strong>include_tf</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – Whether to include <code class="docutils literal notranslate"><span class="pre">tf</span></code> in the window.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries" title="merlion.utils.time_series.UnivariateTimeSeries">UnivariateTimeSeries</a></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The subset of the time series occurring between timestamps
<code class="docutils literal notranslate"><span class="pre">t0</span></code> (inclusive) and <code class="docutils literal notranslate"><span class="pre">tf</span></code> (included if <code class="docutils literal notranslate"><span class="pre">include_tf</span></code> is
<code class="docutils literal notranslate"><span class="pre">True</span></code>, excluded otherwise).</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.time_series.UnivariateTimeSeries.to_dict">
<span class="sig-name descname"><span class="pre">to_dict</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.time_series.UnivariateTimeSeries.to_dict" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Dict</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A dictionary representing the data points in the time series.</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.time_series.UnivariateTimeSeries.from_dict">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_dict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.time_series.UnivariateTimeSeries.from_dict" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Dict</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]) – A dictionary of timestamp - value pairs</p></li>
<li><p><strong>name</strong> – the name to assign the output</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries" title="merlion.utils.time_series.UnivariateTimeSeries">UnivariateTimeSeries</a></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the <a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries" title="merlion.utils.time_series.UnivariateTimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">UnivariateTimeSeries</span></code></a> represented by series.</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.time_series.UnivariateTimeSeries.to_pd">
<span class="sig-name descname"><span class="pre">to_pd</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.time_series.UnivariateTimeSeries.to_pd" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A pandas Series representing the time series, indexed by time.</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.time_series.UnivariateTimeSeries.from_pd">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_pd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">series</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'1h'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.time_series.UnivariateTimeSeries.from_pd" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>series</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code>) – a <code class="docutils literal notranslate"><span class="pre">pd.Series</span></code>. If it has a``pd.DatetimeIndex``, we will
use that index for the timestamps. Otherwise, we will create one at
the specified frequency.</p></li>
<li><p><strong>name</strong> – the name to assign the output</p></li>
<li><p><strong>freq</strong> – if <code class="docutils literal notranslate"><span class="pre">series</span></code> is not indexed by time, this is the frequency
at which we will assume it is sampled.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries" title="merlion.utils.time_series.UnivariateTimeSeries">UnivariateTimeSeries</a></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the <a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries" title="merlion.utils.time_series.UnivariateTimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">UnivariateTimeSeries</span></code></a> represented by series.</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.time_series.UnivariateTimeSeries.to_ts">
<span class="sig-name descname"><span class="pre">to_ts</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.time_series.UnivariateTimeSeries.to_ts" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries">TimeSeries</a></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a> representing this univariate time series.</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.time_series.UnivariateTimeSeries.empty">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">empty</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.time_series.UnivariateTimeSeries.empty" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries" title="merlion.utils.time_series.UnivariateTimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">UnivariateTimeSeries</span></code></a></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A Merlion <a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries" title="merlion.utils.time_series.UnivariateTimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">UnivariateTimeSeries</span></code></a> that has empty timestamps and values.</p>
</dd>
</dl>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="merlion.utils.time_series.TimeSeries">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">merlion.utils.time_series.</span></span><span class="sig-name descname"><span class="pre">TimeSeries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">univariates</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_aligned</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.time_series.TimeSeries" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Please read the <a class="reference internal" href="examples/TimeSeries.html"><span class="doc">tutorial</span></a> before reading this API doc.
This class represents a general multivariate time series as a wrapper around
a number of (optionally named) <a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries" title="merlion.utils.time_series.UnivariateTimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">UnivariateTimeSeries</span></code></a>. A <a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a> object
is initialized as <code class="docutils literal notranslate"><span class="pre">time_series</span> <span class="pre">=</span> <span class="pre">TimeSeries(univariates)</span></code>, where
<code class="docutils literal notranslate"><span class="pre">univariates</span></code> is either a list of <a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries" title="merlion.utils.time_series.UnivariateTimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">UnivariateTimeSeries</span></code></a>, or a dictionary
mapping string names to their corresponding <a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries" title="merlion.utils.time_series.UnivariateTimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">UnivariateTimeSeries</span></code></a> objects.</p>
<p>Because the individual <code class="docutils literal notranslate"><span class="pre">univariates</span></code> need not be sampled at the same times, an
important concept for <a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a> is <em>alignment</em>. We say that a <a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a>
is <em>aligned</em> if all of its univariates have observations sampled at the exact
set set of times.</p>
<p>One may access the <a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries" title="merlion.utils.time_series.UnivariateTimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">UnivariateTimeSeries</span></code></a> comprising this <a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a> in
four ways:</p>
<ol class="arabic">
<li><p>Iterate over the individual univariates using</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">time_series</span><span class="o">.</span><span class="n">univariates</span><span class="p">:</span>
    <span class="c1"># do stuff with each UnivariateTimeSeries var</span>
</pre></div>
</div>
</li>
<li><p>Access an individual <a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries" title="merlion.utils.time_series.UnivariateTimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">UnivariateTimeSeries</span></code></a> by name as
<code class="docutils literal notranslate"><span class="pre">time_series.univariates[name]</span></code>. If you supplied unnamed univariates to
the constructor (i.e. using a list), the name of a univariate will just
be its index in that list.</p></li>
<li><p>Get the list of each univariate’s name with <code class="docutils literal notranslate"><span class="pre">time_series.names</span></code>.</p></li>
<li><p>Iterate over named univariates as</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">time_series</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="c1"># do stuff</span>
</pre></div>
</div>
<p>Note that this is equivalent to iterating over
<code class="docutils literal notranslate"><span class="pre">zip(time_series.names,</span> <span class="pre">time_series.univariates)</span></code>.</p>
</li>
</ol>
<p>This class supports the following additional features as well:</p>
<ol class="arabic">
<li><p>Interoperability with <code class="docutils literal notranslate"><span class="pre">pandas</span></code></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">df</span> <span class="pre">=</span> <span class="pre">time_series.to_pd()</span></code> yields a time-indexed <code class="docutils literal notranslate"><span class="pre">pd.DataFrame</span></code>,
where each column (with the appropriate name) corresponds to a
variable. Missing values are <code class="docutils literal notranslate"><span class="pre">NaN</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">time_series</span> <span class="pre">=</span> <span class="pre">TimeSeries.from_pd(df)</span></code> takes a time-indexed
<code class="docutils literal notranslate"><span class="pre">pd.DataFrame</span></code> and returns a corresponding <a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a> object
(missing values are handled appropriately). The order of
<code class="docutils literal notranslate"><span class="pre">time_series.univariates</span></code> is the order of <code class="docutils literal notranslate"><span class="pre">df.keys()</span></code>.</p></li>
</ul>
</li>
<li><p>Automated alignment: <code class="docutils literal notranslate"><span class="pre">aligned</span> <span class="pre">=</span> <span class="pre">time_series.align()</span></code> resamples each of
<code class="docutils literal notranslate"><span class="pre">time_series.univariates</span></code> so that they all have the same timestamps.
By default, this is done by taking the union of all timestamps present
in any individual univariate time series, and imputing missing values
via interpolation. See the method documentation for details on how you
may configure the alignment policy.</p></li>
<li><p>Transparent indexing and iteration for <a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a> which have all
univariates aligned (i.e. they all have the same timestamps)</p>
<ul>
<li><p>Get the length and shape of the time series (equal to the number of
observations in each individual univariate). Note that if the time
series is not aligned, we will return the length/shape of an equivalent
<code class="docutils literal notranslate"><span class="pre">pandas</span></code> dataframe and emit a warning.</p></li>
<li><p>Index <code class="docutils literal notranslate"><span class="pre">time_series[i]</span> <span class="pre">=</span> <span class="pre">(times[i],</span> <span class="pre">(x1[i],</span> <span class="pre">...,</span> <span class="pre">xn[i]))</span></code>
(assuming <code class="docutils literal notranslate"><span class="pre">time_series</span></code> has <code class="docutils literal notranslate"><span class="pre">n</span></code> aligned univariates with timestamps
<code class="docutils literal notranslate"><span class="pre">times</span></code>, and <code class="docutils literal notranslate"><span class="pre">xk</span> <span class="pre">=</span> <span class="pre">time_series.univariates[k-1].values</span></code>). Slice
returns a <a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a> object and works as one would expect.</p></li>
<li><p>Assuming <code class="docutils literal notranslate"><span class="pre">time_series</span></code> has <code class="docutils literal notranslate"><span class="pre">n</span></code> variables, you may iterate with</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">t_i</span><span class="p">,</span> <span class="p">(</span><span class="n">x1_i</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">xn_i</span><span class="p">)</span> <span class="ow">in</span> <span class="n">time_series</span><span class="p">:</span>
    <span class="c1"># do stuff</span>
</pre></div>
</div>
<p>Notably, this lets you call <code class="docutils literal notranslate"><span class="pre">times,</span> <span class="pre">val_vectors</span> <span class="pre">=</span> <span class="pre">zip(*time_series)</span></code></p>
</li>
</ul>
</li>
<li><p>Time-based queries for any time series</p>
<ul class="simple">
<li><p>Get the two sub <a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a> before and after a timestamp <code class="docutils literal notranslate"><span class="pre">t</span></code> via
<code class="docutils literal notranslate"><span class="pre">left,</span> <span class="pre">right</span> <span class="pre">=</span> <span class="pre">time_series.bisect(t)</span></code></p></li>
<li><p>Get the sub <a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a> between timestamps <code class="docutils literal notranslate"><span class="pre">t0</span></code> (inclusive) and
<code class="docutils literal notranslate"><span class="pre">tf</span></code> (non-inclusive) via <code class="docutils literal notranslate"><span class="pre">window</span> <span class="pre">=</span> <span class="pre">time_series.window(t0,</span> <span class="pre">tf)</span></code></p></li>
</ul>
</li>
<li><p>Concatenation: two <a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a> may be concatenated (in time) as
<code class="docutils literal notranslate"><span class="pre">time_series</span> <span class="pre">=</span> <span class="pre">time_series_1</span> <span class="pre">+</span> <span class="pre">time_series_2</span></code>.</p></li>
</ol>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.time_series.TimeSeries.__getitem__">
<span class="sig-name descname"><span class="pre">__getitem__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.time_series.TimeSeries.__getitem__" title="Permalink to this definition"></a></dt>
<dd><p>Only supported if all individual variable time series are sampled at the
same time stamps.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>i</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">slice</span></code>]) – integer index or slice.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>Union[Tuple[float, Tuple[float]], <a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries">TimeSeries</a>]</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>If <code class="docutils literal notranslate"><span class="pre">i</span></code> is an integer, returns the tuple
<code class="docutils literal notranslate"><span class="pre">(time_stamps[i],</span> <span class="pre">tuple(var.values[i]</span> <span class="pre">for</span> <span class="pre">var</span> <span class="pre">in</span> <span class="pre">self.univariates))</span></code>.
If <code class="docutils literal notranslate"><span class="pre">i</span></code> is a slice, returns the time series
<code class="docutils literal notranslate"><span class="pre">TimeSeries([var[i]</span> <span class="pre">for</span> <span class="pre">var</span> <span class="pre">in</span> <span class="pre">self.univariates])</span></code></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.time_series.TimeSeries.__iter__">
<span class="sig-name descname"><span class="pre">__iter__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.time_series.TimeSeries.__iter__" title="Permalink to this definition"></a></dt>
<dd><p>Only supported if all individual variable time series are sampled at the
same time stamps. The i’th item of the iterator is the tuple
<code class="docutils literal notranslate"><span class="pre">(time_stamps[i],</span> <span class="pre">tuple(var.values[i]</span> <span class="pre">for</span> <span class="pre">var</span> <span class="pre">in</span> <span class="pre">self.univariates))</span></code>.</p>
</dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="merlion.utils.time_series.TimeSeries.names">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">names</span></span><a class="headerlink" href="#merlion.utils.time_series.TimeSeries.names" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The list of the names of the univariates.</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.time_series.TimeSeries.items">
<span class="sig-name descname"><span class="pre">items</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.time_series.TimeSeries.items" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Iterator over <code class="docutils literal notranslate"><span class="pre">(name,</span> <span class="pre">univariate)</span></code> tuples.</p>
</dd>
</dl>
</dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="merlion.utils.time_series.TimeSeries.dim">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dim</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">int</span></em><a class="headerlink" href="#merlion.utils.time_series.TimeSeries.dim" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The dimension of the time series (the number of variables).</p>
</dd>
</dl>
</dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="merlion.utils.time_series.TimeSeries.is_aligned">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_aligned</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">bool</span></em><a class="headerlink" href="#merlion.utils.time_series.TimeSeries.is_aligned" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Whether all individual variable time series are sampled at the
same time stamps, i.e. they are aligned.</p>
</dd>
</dl>
</dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="merlion.utils.time_series.TimeSeries.np_time_stamps">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">np_time_stamps</span></span><a class="headerlink" href="#merlion.utils.time_series.TimeSeries.np_time_stamps" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the <code class="docutils literal notranslate"><span class="pre">numpy</span></code> representation of this time series’s Unix timestamps</p>
</dd>
</dl>
</dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="merlion.utils.time_series.TimeSeries.time_stamps">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">time_stamps</span></span><a class="headerlink" href="#merlion.utils.time_series.TimeSeries.time_stamps" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>List[float]</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the list of Unix timestamps for the time series</p>
</dd>
</dl>
</dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="merlion.utils.time_series.TimeSeries.t0">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">t0</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">float</span></em><a class="headerlink" href="#merlion.utils.time_series.TimeSeries.t0" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the first timestamp in the time series.</p>
</dd>
</dl>
</dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="merlion.utils.time_series.TimeSeries.tf">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">tf</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">float</span></em><a class="headerlink" href="#merlion.utils.time_series.TimeSeries.tf" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the final timestamp in the time series.</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.time_series.TimeSeries.is_empty">
<span class="sig-name descname"><span class="pre">is_empty</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.time_series.TimeSeries.is_empty" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>whether the time series is empty</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.time_series.TimeSeries.squeeze">
<span class="sig-name descname"><span class="pre">squeeze</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.time_series.TimeSeries.squeeze" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries" title="merlion.utils.time_series.UnivariateTimeSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">UnivariateTimeSeries</span></code></a></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a <a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries" title="merlion.utils.time_series.UnivariateTimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">UnivariateTimeSeries</span></code></a> if the time series only
has one univariate, otherwise returns itself, a <a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a></p>
</dd>
</dl>
</dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="merlion.utils.time_series.TimeSeries.shape">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">shape</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#merlion.utils.time_series.TimeSeries.shape" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the shape of this time series, i.e. <code class="docutils literal notranslate"><span class="pre">(self.dim,</span> <span class="pre">len(self))</span></code></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.time_series.TimeSeries.bisect">
<span class="sig-name descname"><span class="pre">bisect</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t_in_left</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.time_series.TimeSeries.bisect" title="Permalink to this definition"></a></dt>
<dd><p>Splits the time series at the point where the given timestap <code class="docutils literal notranslate"><span class="pre">t</span></code> occurs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – a Unix timestamp or datetime object. Everything before time
<code class="docutils literal notranslate"><span class="pre">t</span></code> is in the left split, and everything after time <code class="docutils literal notranslate"><span class="pre">t</span></code> is in
the right split.</p></li>
<li><p><strong>t_in_left</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – if <code class="docutils literal notranslate"><span class="pre">True</span></code>, <code class="docutils literal notranslate"><span class="pre">t</span></code> is in the left split. Otherwise,
<code class="docutils literal notranslate"><span class="pre">t</span></code> is in the right split.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>Tuple[<a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries">TimeSeries</a>, <a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries">TimeSeries</a>]</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the left and right splits of the time series.</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.time_series.TimeSeries.window">
<span class="sig-name descname"><span class="pre">window</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_tf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.time_series.TimeSeries.window" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t0</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – The timestamp/datetime at the start of the window (inclusive)</p></li>
<li><p><strong>tf</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – The timestamp/datetime at the end of the window (inclusive
if <code class="docutils literal notranslate"><span class="pre">include_tf</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, non-inclusive otherwise)</p></li>
<li><p><strong>include_tf</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – Whether to include <code class="docutils literal notranslate"><span class="pre">tf</span></code> in the window.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The subset of the time series occurring between timestamps
<code class="docutils literal notranslate"><span class="pre">t0</span></code> (inclusive) and <code class="docutils literal notranslate"><span class="pre">tf</span></code> (included if <code class="docutils literal notranslate"><span class="pre">include_tf</span></code> is
<code class="docutils literal notranslate"><span class="pre">True</span></code>, excluded otherwise).</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.time_series.TimeSeries.to_pd">
<span class="sig-name descname"><span class="pre">to_pd</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.time_series.TimeSeries.to_pd" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A pandas DataFrame (indexed by time) which represents this time
series. Each variable corresponds to a column of the DataFrame.
Timestamps which are present for one variable but not another, are
represented with NaN.</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.time_series.TimeSeries.from_pd">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_pd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">df</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_times</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'1h'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.time_series.TimeSeries.from_pd" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>df</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>]) – A pandas DataFrame with a DatetimeIndex. Each column
corresponds to a different variable of the time series, and the
key of column (in sorted order) give the relative order of those
variables (in the list self.univariates). Missing values should be
represented with <code class="docutils literal notranslate"><span class="pre">NaN</span></code>. May also be a pandas Series for univariate
time series.</p></li>
<li><p><strong>check_times</strong> – whether to check that all times in the index are
unique (up to the millisecond) and sorted.</p></li>
<li><p><strong>freq</strong> – if <code class="docutils literal notranslate"><span class="pre">df</span></code> is not indexed by time, this is the frequency
at which we will assume it is sampled.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries">TimeSeries</a></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the <a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a> object corresponding to <code class="docutils literal notranslate"><span class="pre">df</span></code>.</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.time_series.TimeSeries.from_ts_list">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_ts_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ts_list</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_aligned</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.time_series.TimeSeries.from_ts_list" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ts_list</strong> (<em>Iterable</em><em>[</em><a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><em>TimeSeries</em></a><em>]</em>) – iterable of time series we wish to
form a multivariate time series with</p></li>
<li><p><strong>check_aligned</strong> (<em>bool</em>) – whether to check if the output time series is
aligned</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries">TimeSeries</a></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A multivariate <a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a> created from all the time series in
the inputs.</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.time_series.TimeSeries.align">
<span class="sig-name descname"><span class="pre">align</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reference</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">granularity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">remove_non_overlapping</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alignment_policy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">aggregation_policy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">AggregationPolicy.Mean</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">missing_value_policy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">MissingValuePolicy.Interpolate</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.time_series.TimeSeries.align" title="Permalink to this definition"></a></dt>
<dd><p>Aligns all the univariate time series comprising this multivariate time
series so that they all have the same time stamps.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reference</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code>[<code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]]]) – A specific set of timestamps we want the resampled
time series to contain. Required if <code class="docutils literal notranslate"><span class="pre">alignment_policy</span></code> is
<a class="reference internal" href="#merlion.utils.resample.AlignPolicy.FixedReference" title="merlion.utils.resample.AlignPolicy.FixedReference"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">AlignPolicy.FixedReference</span></code></a>. Overrides other alignment policies
if specified.</p></li>
<li><p><strong>granularity</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>]) – The granularity (in seconds) of the resampled time
time series. Defaults to the GCD time difference between adjacent
elements of <code class="docutils literal notranslate"><span class="pre">reference</span></code> (when available) or <code class="docutils literal notranslate"><span class="pre">time_series</span></code>
(otherwise). Ignored if <code class="docutils literal notranslate"><span class="pre">reference</span></code> is given or <code class="docutils literal notranslate"><span class="pre">alignment_policy</span></code>
is <a class="reference internal" href="#merlion.utils.resample.AlignPolicy.FixedReference" title="merlion.utils.resample.AlignPolicy.FixedReference"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">AlignPolicy.FixedReference</span></code></a>. Overrides other alignment policies
if specified.</p></li>
<li><p><strong>origin</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]) – The first timestamp of the resampled time series. Only
used if the alignment policy is AlignPolicy.FixedGranularity.</p></li>
<li><p><strong>remove_non_overlapping</strong> – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, we will only keep the portions
of the univariates that overlap with each other. For example, if we
have 3 univariates which span timestamps [0, 3600], [60, 3660], and
[30, 3540], we will only keep timestamps in the range [60, 3540]. If
<code class="docutils literal notranslate"><span class="pre">False</span></code>, we will keep all timestamps produced by the resampling.</p></li>
<li><p><strong>alignment_policy</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<a class="reference internal" href="#merlion.utils.resample.AlignPolicy" title="merlion.utils.resample.AlignPolicy"><code class="xref py py-class docutils literal notranslate"><span class="pre">AlignPolicy</span></code></a>]) – <p>The policy we want to use to align the time
time series.</p>
<ul>
<li><p><a class="reference internal" href="#merlion.utils.resample.AlignPolicy.FixedReference" title="merlion.utils.resample.AlignPolicy.FixedReference"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">AlignPolicy.FixedReference</span></code></a> aligns each single-variable time
series to <code class="docutils literal notranslate"><span class="pre">reference</span></code>, a user-specified sequence of timestamps.</p></li>
<li><p><a class="reference internal" href="#merlion.utils.resample.AlignPolicy.FixedGranularity" title="merlion.utils.resample.AlignPolicy.FixedGranularity"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">AlignPolicy.FixedGranularity</span></code></a> resamples each single-variable time
series at the same granularity, aggregating windows and imputing
missing values as desired.</p></li>
<li><p><a class="reference internal" href="#merlion.utils.resample.AlignPolicy.OuterJoin" title="merlion.utils.resample.AlignPolicy.OuterJoin"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">AlignPolicy.OuterJoin</span></code></a> returns a time series with the union of
all timestamps present in any single-variable time series.</p></li>
<li><p><a class="reference internal" href="#merlion.utils.resample.AlignPolicy.InnerJoin" title="merlion.utils.resample.AlignPolicy.InnerJoin"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">AlignPolicy.InnerJoin</span></code></a> returns a time series with the intersection
of all timestamps present in all single-variable time series.</p></li>
</ul>
</p></li>
<li><p><strong>aggregation_policy</strong> (<a class="reference internal" href="#merlion.utils.resample.AggregationPolicy" title="merlion.utils.resample.AggregationPolicy"><code class="xref py py-class docutils literal notranslate"><span class="pre">AggregationPolicy</span></code></a>) – The policy used to aggregate windows of adjacent
observations when downsampling.</p></li>
<li><p><strong>missing_value_policy</strong> (<a class="reference internal" href="#merlion.utils.resample.MissingValuePolicy" title="merlion.utils.resample.MissingValuePolicy"><code class="xref py py-class docutils literal notranslate"><span class="pre">MissingValuePolicy</span></code></a>) – The policy used to impute missing values
created when upsampling.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries">TimeSeries</a></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The resampled multivariate time series.</p>
</dd>
</dl>
</dd></dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="merlion.utils.time_series.ts_csv_load">
<span class="sig-prename descclassname"><span class="pre">merlion.utils.time_series.</span></span><span class="sig-name descname"><span class="pre">ts_csv_load</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ms</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_vars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.time_series.ts_csv_load" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_name</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – a csv file starting with the field timestamp followed by
all the all variable names.</p></li>
<li><p><strong>ms</strong> – whether the timestamps are in milliseconds (rather than seconds)</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A merlion <a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a> object.</p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="merlion.utils.time_series.ts_to_csv">
<span class="sig-prename descclassname"><span class="pre">merlion.utils.time_series.</span></span><span class="sig-name descname"><span class="pre">ts_to_csv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_series</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.time_series.ts_to_csv" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>time_series</strong> (<a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a>) – the <a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a> object to write to a csv.</p></li>
<li><p><strong>file_name</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – the name to assign the csv file.</p></li>
</ul>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="merlion.utils.time_series.assert_equal_timedeltas">
<span class="sig-prename descclassname"><span class="pre">merlion.utils.time_series.</span></span><span class="sig-name descname"><span class="pre">assert_equal_timedeltas</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_series</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timedelta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.time_series.assert_equal_timedeltas" title="Permalink to this definition"></a></dt>
<dd><p>Checks that all time deltas in the time series are equal, either to each
other, or a pre-specified timedelta (in seconds).</p>
</dd></dl>
</section>
</section>
</div>
</div>
<footer><div aria-label="Footer" class="rst-footer-buttons" role="navigation">
<a accesskey="p" class="btn btn-neutral float-left" href="merlion.evaluate.html" rel="prev" title="merlion.evaluate package"><span aria-hidden="true" class="fa fa-arrow-circle-left"></span> Previous</a>
<a accesskey="n" class="btn btn-neutral float-right" href="ts_datasets.html" rel="next" title="ts_datasets: Easy Data Loading">Next <span aria-hidden="true" class="fa fa-arrow-circle-right"></span></a>
</div>
<hr/>
<div role="contentinfo">
<p>© Copyright 2021, salesforce.com, inc..</p>
</div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
</div>
</div>
</section>
</div>
<div aria-label="versions" class="rst-versions" data-toggle="rst-versions" role="note">
<span class="rst-current-version" data-toggle="rst-current-version">
<span class="fa fa-book"> Versions</span>
      v1.1.1
      <span class="fa fa-caret-down"></span>
</span>
<div class="rst-other-versions">
<dl><dt>Versions</dt><dd><a href="../latest/index.html">latest</a></dd><dd><a href="../v2.0.0/index.html">v2.0.0</a></dd><dd><a href="../v1.3.1/index.html">v1.3.1</a></dd><dd><a href="../v1.3.0/index.html">v1.3.0</a></dd><dd><a href="../v1.2.5/index.html">v1.2.5</a></dd><dd><a href="../v1.2.4/index.html">v1.2.4</a></dd><dd><a href="../v1.2.3/index.html">v1.2.3</a></dd><dd><a href="../v1.2.2/index.html">v1.2.2</a></dd><dd><a href="../v1.2.1/index.html">v1.2.1</a></dd><dd><a href="../v1.2.0/index.html">v1.2.0</a></dd><dd><a href="../v1.1.3/index.html">v1.1.3</a></dd><dd><a href="../v1.1.2/index.html">v1.1.2</a></dd><dd><strong><a href="../v1.1.1/index.html">v1.1.1</a></strong></dd><dd><a href="../v1.1.0/index.html">v1.1.0</a></dd><dd><a href="../v1.0.2/index.html">v1.0.2</a></dd><dd><a href="../v1.0.1/index.html">v1.0.1</a></dd><dd><a href="../v1.0.0/index.html">v1.0.0</a></dd></dl>
</div>
</div>
<script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
</body>
</html>