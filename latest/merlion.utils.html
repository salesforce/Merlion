<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>merlion.utils package &mdash; Merlion 1.3.1 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="ts_datasets: Easy Data Loading" href="ts_datasets.html" />
    <link rel="prev" title="merlion.evaluate package" href="merlion.evaluate.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> Merlion
          </a>
              <div class="version">
                latest
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="merlion.html">merlion: Time Series Intelligence</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="merlion.html#subpackages">Subpackages</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="merlion.models.html">merlion.models package</a></li>
<li class="toctree-l3"><a class="reference internal" href="merlion.spark.html">merlion.spark package</a></li>
<li class="toctree-l3"><a class="reference internal" href="merlion.transform.html">merlion.transform package</a></li>
<li class="toctree-l3"><a class="reference internal" href="merlion.post_process.html">merlion.post_process package</a></li>
<li class="toctree-l3"><a class="reference internal" href="merlion.evaluate.html">merlion.evaluate package</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">merlion.utils package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#submodules">Submodules</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-merlion.utils.time_series">merlion.utils.time_series module</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries"><code class="docutils literal notranslate"><span class="pre">UnivariateTimeSeries</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries.__getitem__"><code class="docutils literal notranslate"><span class="pre">UnivariateTimeSeries.__getitem__()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries.__iter__"><code class="docutils literal notranslate"><span class="pre">UnivariateTimeSeries.__iter__()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries.np_time_stamps"><code class="docutils literal notranslate"><span class="pre">UnivariateTimeSeries.np_time_stamps</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries.np_values"><code class="docutils literal notranslate"><span class="pre">UnivariateTimeSeries.np_values</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries.time_stamps"><code class="docutils literal notranslate"><span class="pre">UnivariateTimeSeries.time_stamps</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries.values"><code class="docutils literal notranslate"><span class="pre">UnivariateTimeSeries.values</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries.t0"><code class="docutils literal notranslate"><span class="pre">UnivariateTimeSeries.t0</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries.tf"><code class="docutils literal notranslate"><span class="pre">UnivariateTimeSeries.tf</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries.is_empty"><code class="docutils literal notranslate"><span class="pre">UnivariateTimeSeries.is_empty()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries.copy"><code class="docutils literal notranslate"><span class="pre">UnivariateTimeSeries.copy()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries.concat"><code class="docutils literal notranslate"><span class="pre">UnivariateTimeSeries.concat()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries.bisect"><code class="docutils literal notranslate"><span class="pre">UnivariateTimeSeries.bisect()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries.window"><code class="docutils literal notranslate"><span class="pre">UnivariateTimeSeries.window()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries.to_dict"><code class="docutils literal notranslate"><span class="pre">UnivariateTimeSeries.to_dict()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries.from_dict"><code class="docutils literal notranslate"><span class="pre">UnivariateTimeSeries.from_dict()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries.to_pd"><code class="docutils literal notranslate"><span class="pre">UnivariateTimeSeries.to_pd()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries.from_pd"><code class="docutils literal notranslate"><span class="pre">UnivariateTimeSeries.from_pd()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries.to_ts"><code class="docutils literal notranslate"><span class="pre">UnivariateTimeSeries.to_ts()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries.empty"><code class="docutils literal notranslate"><span class="pre">UnivariateTimeSeries.empty()</span></code></a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="#merlion.utils.time_series.TimeSeries"><code class="docutils literal notranslate"><span class="pre">TimeSeries</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.time_series.TimeSeries.__getitem__"><code class="docutils literal notranslate"><span class="pre">TimeSeries.__getitem__()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.time_series.TimeSeries.__iter__"><code class="docutils literal notranslate"><span class="pre">TimeSeries.__iter__()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.time_series.TimeSeries.names"><code class="docutils literal notranslate"><span class="pre">TimeSeries.names</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.time_series.TimeSeries.items"><code class="docutils literal notranslate"><span class="pre">TimeSeries.items()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.time_series.TimeSeries.dim"><code class="docutils literal notranslate"><span class="pre">TimeSeries.dim</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.time_series.TimeSeries.rename"><code class="docutils literal notranslate"><span class="pre">TimeSeries.rename()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.time_series.TimeSeries.is_aligned"><code class="docutils literal notranslate"><span class="pre">TimeSeries.is_aligned</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.time_series.TimeSeries.np_time_stamps"><code class="docutils literal notranslate"><span class="pre">TimeSeries.np_time_stamps</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.time_series.TimeSeries.time_stamps"><code class="docutils literal notranslate"><span class="pre">TimeSeries.time_stamps</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.time_series.TimeSeries.t0"><code class="docutils literal notranslate"><span class="pre">TimeSeries.t0</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.time_series.TimeSeries.tf"><code class="docutils literal notranslate"><span class="pre">TimeSeries.tf</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.time_series.TimeSeries.is_empty"><code class="docutils literal notranslate"><span class="pre">TimeSeries.is_empty()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.time_series.TimeSeries.squeeze"><code class="docutils literal notranslate"><span class="pre">TimeSeries.squeeze()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.time_series.TimeSeries.shape"><code class="docutils literal notranslate"><span class="pre">TimeSeries.shape</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.time_series.TimeSeries.bisect"><code class="docutils literal notranslate"><span class="pre">TimeSeries.bisect()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.time_series.TimeSeries.window"><code class="docutils literal notranslate"><span class="pre">TimeSeries.window()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.time_series.TimeSeries.to_pd"><code class="docutils literal notranslate"><span class="pre">TimeSeries.to_pd()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.time_series.TimeSeries.to_csv"><code class="docutils literal notranslate"><span class="pre">TimeSeries.to_csv()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.time_series.TimeSeries.from_pd"><code class="docutils literal notranslate"><span class="pre">TimeSeries.from_pd()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.time_series.TimeSeries.from_ts_list"><code class="docutils literal notranslate"><span class="pre">TimeSeries.from_ts_list()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.time_series.TimeSeries.align"><code class="docutils literal notranslate"><span class="pre">TimeSeries.align()</span></code></a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="#merlion.utils.time_series.assert_equal_timedeltas"><code class="docutils literal notranslate"><span class="pre">assert_equal_timedeltas()</span></code></a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#module-merlion.utils.resample">merlion.utils.resample module</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#merlion.utils.resample.AlignPolicy"><code class="docutils literal notranslate"><span class="pre">AlignPolicy</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.resample.AlignPolicy.OuterJoin"><code class="docutils literal notranslate"><span class="pre">AlignPolicy.OuterJoin</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.resample.AlignPolicy.InnerJoin"><code class="docutils literal notranslate"><span class="pre">AlignPolicy.InnerJoin</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.resample.AlignPolicy.FixedReference"><code class="docutils literal notranslate"><span class="pre">AlignPolicy.FixedReference</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.resample.AlignPolicy.FixedGranularity"><code class="docutils literal notranslate"><span class="pre">AlignPolicy.FixedGranularity</span></code></a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="#merlion.utils.resample.AggregationPolicy"><code class="docutils literal notranslate"><span class="pre">AggregationPolicy</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.resample.AggregationPolicy.Mean"><code class="docutils literal notranslate"><span class="pre">AggregationPolicy.Mean</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.resample.AggregationPolicy.Sum"><code class="docutils literal notranslate"><span class="pre">AggregationPolicy.Sum</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.resample.AggregationPolicy.Median"><code class="docutils literal notranslate"><span class="pre">AggregationPolicy.Median</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.resample.AggregationPolicy.First"><code class="docutils literal notranslate"><span class="pre">AggregationPolicy.First</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.resample.AggregationPolicy.Last"><code class="docutils literal notranslate"><span class="pre">AggregationPolicy.Last</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.resample.AggregationPolicy.Min"><code class="docutils literal notranslate"><span class="pre">AggregationPolicy.Min</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.resample.AggregationPolicy.Max"><code class="docutils literal notranslate"><span class="pre">AggregationPolicy.Max</span></code></a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="#merlion.utils.resample.MissingValuePolicy"><code class="docutils literal notranslate"><span class="pre">MissingValuePolicy</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.resample.MissingValuePolicy.FFill"><code class="docutils literal notranslate"><span class="pre">MissingValuePolicy.FFill</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.resample.MissingValuePolicy.BFill"><code class="docutils literal notranslate"><span class="pre">MissingValuePolicy.BFill</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.resample.MissingValuePolicy.Nearest"><code class="docutils literal notranslate"><span class="pre">MissingValuePolicy.Nearest</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.resample.MissingValuePolicy.Interpolate"><code class="docutils literal notranslate"><span class="pre">MissingValuePolicy.Interpolate</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.resample.MissingValuePolicy.ZFill"><code class="docutils literal notranslate"><span class="pre">MissingValuePolicy.ZFill</span></code></a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="#merlion.utils.resample.to_pd_datetime"><code class="docutils literal notranslate"><span class="pre">to_pd_datetime()</span></code></a></li>
<li class="toctree-l5"><a class="reference internal" href="#merlion.utils.resample.to_timestamp"><code class="docutils literal notranslate"><span class="pre">to_timestamp()</span></code></a></li>
<li class="toctree-l5"><a class="reference internal" href="#merlion.utils.resample.granularity_str_to_seconds"><code class="docutils literal notranslate"><span class="pre">granularity_str_to_seconds()</span></code></a></li>
<li class="toctree-l5"><a class="reference internal" href="#merlion.utils.resample.get_gcd_timedelta"><code class="docutils literal notranslate"><span class="pre">get_gcd_timedelta()</span></code></a></li>
<li class="toctree-l5"><a class="reference internal" href="#merlion.utils.resample.infer_granularity"><code class="docutils literal notranslate"><span class="pre">infer_granularity()</span></code></a></li>
<li class="toctree-l5"><a class="reference internal" href="#merlion.utils.resample.reindex_df"><code class="docutils literal notranslate"><span class="pre">reindex_df()</span></code></a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#module-merlion.utils.data_io">merlion.utils.data_io module</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#merlion.utils.data_io.df_to_time_series"><code class="docutils literal notranslate"><span class="pre">df_to_time_series()</span></code></a></li>
<li class="toctree-l5"><a class="reference internal" href="#merlion.utils.data_io.data_io_decorator"><code class="docutils literal notranslate"><span class="pre">data_io_decorator()</span></code></a></li>
<li class="toctree-l5"><a class="reference internal" href="#merlion.utils.data_io.csv_to_time_series"><code class="docutils literal notranslate"><span class="pre">csv_to_time_series()</span></code></a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#module-merlion.utils.hts">merlion.utils.hts module</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#merlion.utils.hts.minT_reconciliation"><code class="docutils literal notranslate"><span class="pre">minT_reconciliation()</span></code></a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#module-merlion.utils.ts_generator">merlion.utils.ts_generator module</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#merlion.utils.ts_generator.TimeSeriesGenerator"><code class="docutils literal notranslate"><span class="pre">TimeSeriesGenerator</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.ts_generator.TimeSeriesGenerator.n"><code class="docutils literal notranslate"><span class="pre">TimeSeriesGenerator.n</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.ts_generator.TimeSeriesGenerator.x0"><code class="docutils literal notranslate"><span class="pre">TimeSeriesGenerator.x0</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.ts_generator.TimeSeriesGenerator.step"><code class="docutils literal notranslate"><span class="pre">TimeSeriesGenerator.step</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.ts_generator.TimeSeriesGenerator.y"><code class="docutils literal notranslate"><span class="pre">TimeSeriesGenerator.y()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.ts_generator.TimeSeriesGenerator.generate"><code class="docutils literal notranslate"><span class="pre">TimeSeriesGenerator.generate()</span></code></a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="#merlion.utils.ts_generator.GeneratorComposer"><code class="docutils literal notranslate"><span class="pre">GeneratorComposer</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.ts_generator.GeneratorComposer.generators"><code class="docutils literal notranslate"><span class="pre">GeneratorComposer.generators</span></code></a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="#merlion.utils.ts_generator.GeneratorConcatenator"><code class="docutils literal notranslate"><span class="pre">GeneratorConcatenator</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.ts_generator.GeneratorConcatenator.generators"><code class="docutils literal notranslate"><span class="pre">GeneratorConcatenator.generators</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.ts_generator.GeneratorConcatenator.y"><code class="docutils literal notranslate"><span class="pre">GeneratorConcatenator.y()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#module-merlion.utils.conj_priors">merlion.utils.conj_priors module</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#merlion.utils.conj_priors.ConjPrior"><code class="docutils literal notranslate"><span class="pre">ConjPrior</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.conj_priors.ConjPrior.to_dict"><code class="docutils literal notranslate"><span class="pre">ConjPrior.to_dict()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.conj_priors.ConjPrior.from_dict"><code class="docutils literal notranslate"><span class="pre">ConjPrior.from_dict()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.conj_priors.ConjPrior.get_time_series_values"><code class="docutils literal notranslate"><span class="pre">ConjPrior.get_time_series_values()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.conj_priors.ConjPrior.process_time_series"><code class="docutils literal notranslate"><span class="pre">ConjPrior.process_time_series()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.conj_priors.ConjPrior.posterior"><code class="docutils literal notranslate"><span class="pre">ConjPrior.posterior()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.conj_priors.ConjPrior.update"><code class="docutils literal notranslate"><span class="pre">ConjPrior.update()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.conj_priors.ConjPrior.forecast"><code class="docutils literal notranslate"><span class="pre">ConjPrior.forecast()</span></code></a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="#merlion.utils.conj_priors.ScalarConjPrior"><code class="docutils literal notranslate"><span class="pre">ScalarConjPrior</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.conj_priors.ScalarConjPrior.process_time_series"><code class="docutils literal notranslate"><span class="pre">ScalarConjPrior.process_time_series()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.conj_priors.ScalarConjPrior.get_time_series_values"><code class="docutils literal notranslate"><span class="pre">ScalarConjPrior.get_time_series_values()</span></code></a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="#merlion.utils.conj_priors.BetaBernoulli"><code class="docutils literal notranslate"><span class="pre">BetaBernoulli</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.conj_priors.BetaBernoulli.posterior"><code class="docutils literal notranslate"><span class="pre">BetaBernoulli.posterior()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.conj_priors.BetaBernoulli.theta_posterior"><code class="docutils literal notranslate"><span class="pre">BetaBernoulli.theta_posterior()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.conj_priors.BetaBernoulli.update"><code class="docutils literal notranslate"><span class="pre">BetaBernoulli.update()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.conj_priors.BetaBernoulli.forecast"><code class="docutils literal notranslate"><span class="pre">BetaBernoulli.forecast()</span></code></a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="#merlion.utils.conj_priors.NormInvGamma"><code class="docutils literal notranslate"><span class="pre">NormInvGamma</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.conj_priors.NormInvGamma.update"><code class="docutils literal notranslate"><span class="pre">NormInvGamma.update()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.conj_priors.NormInvGamma.mu_posterior"><code class="docutils literal notranslate"><span class="pre">NormInvGamma.mu_posterior()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.conj_priors.NormInvGamma.sigma2_posterior"><code class="docutils literal notranslate"><span class="pre">NormInvGamma.sigma2_posterior()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.conj_priors.NormInvGamma.posterior"><code class="docutils literal notranslate"><span class="pre">NormInvGamma.posterior()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.conj_priors.NormInvGamma.forecast"><code class="docutils literal notranslate"><span class="pre">NormInvGamma.forecast()</span></code></a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="#merlion.utils.conj_priors.MVNormInvWishart"><code class="docutils literal notranslate"><span class="pre">MVNormInvWishart</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.conj_priors.MVNormInvWishart.process_time_series"><code class="docutils literal notranslate"><span class="pre">MVNormInvWishart.process_time_series()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.conj_priors.MVNormInvWishart.update"><code class="docutils literal notranslate"><span class="pre">MVNormInvWishart.update()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.conj_priors.MVNormInvWishart.mu_posterior"><code class="docutils literal notranslate"><span class="pre">MVNormInvWishart.mu_posterior()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.conj_priors.MVNormInvWishart.Sigma_posterior"><code class="docutils literal notranslate"><span class="pre">MVNormInvWishart.Sigma_posterior()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.conj_priors.MVNormInvWishart.posterior"><code class="docutils literal notranslate"><span class="pre">MVNormInvWishart.posterior()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.conj_priors.MVNormInvWishart.forecast"><code class="docutils literal notranslate"><span class="pre">MVNormInvWishart.forecast()</span></code></a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="#merlion.utils.conj_priors.BayesianLinReg"><code class="docutils literal notranslate"><span class="pre">BayesianLinReg</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.conj_priors.BayesianLinReg.update"><code class="docutils literal notranslate"><span class="pre">BayesianLinReg.update()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.conj_priors.BayesianLinReg.posterior_explicit"><code class="docutils literal notranslate"><span class="pre">BayesianLinReg.posterior_explicit()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.conj_priors.BayesianLinReg.posterior"><code class="docutils literal notranslate"><span class="pre">BayesianLinReg.posterior()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.conj_priors.BayesianLinReg.forecast"><code class="docutils literal notranslate"><span class="pre">BayesianLinReg.forecast()</span></code></a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="#merlion.utils.conj_priors.BayesianMVLinReg"><code class="docutils literal notranslate"><span class="pre">BayesianMVLinReg</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.conj_priors.BayesianMVLinReg.process_time_series"><code class="docutils literal notranslate"><span class="pre">BayesianMVLinReg.process_time_series()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.conj_priors.BayesianMVLinReg.update"><code class="docutils literal notranslate"><span class="pre">BayesianMVLinReg.update()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.conj_priors.BayesianMVLinReg.posterior_explicit"><code class="docutils literal notranslate"><span class="pre">BayesianMVLinReg.posterior_explicit()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.conj_priors.BayesianMVLinReg.posterior"><code class="docutils literal notranslate"><span class="pre">BayesianMVLinReg.posterior()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.conj_priors.BayesianMVLinReg.forecast"><code class="docutils literal notranslate"><span class="pre">BayesianMVLinReg.forecast()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#module-merlion.utils.istat">merlion.utils.istat module</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#merlion.utils.istat.IStat"><code class="docutils literal notranslate"><span class="pre">IStat</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.istat.IStat.n"><code class="docutils literal notranslate"><span class="pre">IStat.n</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.istat.IStat.value"><code class="docutils literal notranslate"><span class="pre">IStat.value</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.istat.IStat.add"><code class="docutils literal notranslate"><span class="pre">IStat.add()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.istat.IStat.drop"><code class="docutils literal notranslate"><span class="pre">IStat.drop()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.istat.IStat.add_batch"><code class="docutils literal notranslate"><span class="pre">IStat.add_batch()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.istat.IStat.drop_batch"><code class="docutils literal notranslate"><span class="pre">IStat.drop_batch()</span></code></a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="#merlion.utils.istat.Mean"><code class="docutils literal notranslate"><span class="pre">Mean</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.istat.Mean.value"><code class="docutils literal notranslate"><span class="pre">Mean.value</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.istat.Mean.add"><code class="docutils literal notranslate"><span class="pre">Mean.add()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.istat.Mean.drop"><code class="docutils literal notranslate"><span class="pre">Mean.drop()</span></code></a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="#merlion.utils.istat.Variance"><code class="docutils literal notranslate"><span class="pre">Variance</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.istat.Variance.mean_class"><code class="docutils literal notranslate"><span class="pre">Variance.mean_class</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.istat.Variance.add"><code class="docutils literal notranslate"><span class="pre">Variance.add()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.istat.Variance.drop"><code class="docutils literal notranslate"><span class="pre">Variance.drop()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.istat.Variance.true_value"><code class="docutils literal notranslate"><span class="pre">Variance.true_value</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.istat.Variance.corrected_value"><code class="docutils literal notranslate"><span class="pre">Variance.corrected_value</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.istat.Variance.value"><code class="docutils literal notranslate"><span class="pre">Variance.value</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.istat.Variance.sd"><code class="docutils literal notranslate"><span class="pre">Variance.sd</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.istat.Variance.se"><code class="docutils literal notranslate"><span class="pre">Variance.se</span></code></a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="#merlion.utils.istat.ExponentialMovingAverage"><code class="docutils literal notranslate"><span class="pre">ExponentialMovingAverage</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.istat.ExponentialMovingAverage.recency_weight"><code class="docutils literal notranslate"><span class="pre">ExponentialMovingAverage.recency_weight</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.istat.ExponentialMovingAverage.value"><code class="docutils literal notranslate"><span class="pre">ExponentialMovingAverage.value</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.istat.ExponentialMovingAverage.drop"><code class="docutils literal notranslate"><span class="pre">ExponentialMovingAverage.drop()</span></code></a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="#merlion.utils.istat.RecencyWeightedVariance"><code class="docutils literal notranslate"><span class="pre">RecencyWeightedVariance</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.istat.RecencyWeightedVariance.mean_class"><code class="docutils literal notranslate"><span class="pre">RecencyWeightedVariance.mean_class</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.istat.RecencyWeightedVariance.recency_weight"><code class="docutils literal notranslate"><span class="pre">RecencyWeightedVariance.recency_weight</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#merlion.utils.istat.RecencyWeightedVariance.drop"><code class="docutils literal notranslate"><span class="pre">RecencyWeightedVariance.drop()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="merlion.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="merlion.html#module-merlion.plot">merlion.plot module</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ts_datasets.html">ts_datasets: Easy Data Loading</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials.html">Tutorials &amp; Example Code</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Merlion</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="merlion.html">merlion: Time Series Intelligence</a> &raquo;</li>
      <li>merlion.utils package</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/merlion.utils.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<section id="merlion-utils-package">
<h1>merlion.utils package<a class="headerlink" href="#merlion-utils-package" title="Permalink to this heading"></a></h1>
<p>This package contains various utilities, including the <a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a> class and
utilities for resampling time series.</p>
<span class="target" id="module-merlion.utils"></span><table class="autosummary longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#module-merlion.utils.time_series" title="merlion.utils.time_series"><code class="xref py py-obj docutils literal notranslate"><span class="pre">time_series</span></code></a></p></td>
<td><p>Implementation of <a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a> class.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#module-merlion.utils.resample" title="merlion.utils.resample"><code class="xref py py-obj docutils literal notranslate"><span class="pre">resample</span></code></a></p></td>
<td><p>Code for resampling time series.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#module-merlion.utils.data_io" title="merlion.utils.data_io"><code class="xref py py-obj docutils literal notranslate"><span class="pre">data_io</span></code></a></p></td>
<td><p>Utils for data I/O.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#module-merlion.utils.hts" title="merlion.utils.hts"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hts</span></code></a></p></td>
<td><p>Aggregation for hierarchical time series.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#module-merlion.utils.ts_generator" title="merlion.utils.ts_generator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ts_generator</span></code></a></p></td>
<td><p>Generators for synthetic time series.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#module-merlion.utils.conj_priors" title="merlion.utils.conj_priors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">conj_priors</span></code></a></p></td>
<td><p>Implementations of Bayesian conjugate priors &amp; their online update rules.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#module-merlion.utils.istat" title="merlion.utils.istat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">istat</span></code></a></p></td>
<td><p>Incremental computation of time series statistics.</p></td>
</tr>
</tbody>
</table>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this heading"></a></h2>
</section>
<section id="module-merlion.utils.time_series">
<span id="merlion-utils-time-series-module"></span><h2>merlion.utils.time_series module<a class="headerlink" href="#module-merlion.utils.time_series" title="Permalink to this heading"></a></h2>
<p>Implementation of <a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a> class.</p>
<dl class="py class">
<dt class="sig sig-object py" id="merlion.utils.time_series.UnivariateTimeSeries">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">merlion.utils.time_series.</span></span><span class="sig-name descname"><span class="pre">UnivariateTimeSeries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_stamps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'1h'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.time_series.UnivariateTimeSeries" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code></p>
<p>Please read the <a class="reference internal" href="tutorials/TimeSeries.html"><span class="doc">tutorial</span></a> before reading this API doc.
This class is a time-indexed <code class="docutils literal notranslate"><span class="pre">pd.Series</span></code> which represents a univariate
time series. For the most part, it supports all the same features as
<code class="docutils literal notranslate"><span class="pre">pd.Series</span></code>, with the following key differences to iteration and indexing:</p>
<ol class="arabic">
<li><p>Iterating over a <a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries" title="merlion.utils.time_series.UnivariateTimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">UnivariateTimeSeries</span></code></a> is implemented as</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">univariate</span><span class="p">:</span>
    <span class="c1"># do stuff...</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">timestamp</span></code> is a Unix timestamp, and <code class="docutils literal notranslate"><span class="pre">value</span></code> is the
corresponding time series value.</p>
</li>
<li><p>Integer index: <code class="docutils literal notranslate"><span class="pre">u[i]</span></code> yields the tuple <code class="docutils literal notranslate"><span class="pre">(u.time_stamps[i],</span> <span class="pre">u.values[i])</span></code></p></li>
<li><p>Slice index: <code class="docutils literal notranslate"><span class="pre">u[i:j:k]</span></code> yields a new
<code class="docutils literal notranslate"><span class="pre">UnivariateTimeSeries(u.time_stamps[i:j:k],</span> <span class="pre">u.values[i:j:k])</span></code></p></li>
</ol>
<p>The class also supports the following additional features:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">univariate.time_stamps</span></code> returns the list of Unix timestamps, and
<code class="docutils literal notranslate"><span class="pre">univariate.values</span></code> returns the list of the time series values. You
may access the <code class="docutils literal notranslate"><span class="pre">pd.DatetimeIndex</span></code> directly with <code class="docutils literal notranslate"><span class="pre">univariate.index</span></code>
(or its <code class="docutils literal notranslate"><span class="pre">np.ndarray</span></code> representation with <code class="docutils literal notranslate"><span class="pre">univariate.np_time_stamps</span></code>),
and the <code class="docutils literal notranslate"><span class="pre">np.ndarray</span></code> of values with <code class="docutils literal notranslate"><span class="pre">univariate.np_values</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">univariate.concat(other)</span></code> will concatenate the UnivariateTimeSeries
<code class="docutils literal notranslate"><span class="pre">other</span></code> to the right end of <code class="docutils literal notranslate"><span class="pre">univariate</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">left,</span> <span class="pre">right</span> <span class="pre">=</span> <span class="pre">univariate.bisect(t)</span></code> will split the univariate at the
given timestamp <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">window</span> <span class="pre">=</span> <span class="pre">univariate.window(t0,</span> <span class="pre">tf)</span></code> will return the subset of the time
series occurring between timestamps <code class="docutils literal notranslate"><span class="pre">t0</span></code> (inclusive) and <code class="docutils literal notranslate"><span class="pre">tf</span></code>
(non-inclusive)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">series</span> <span class="pre">=</span> <span class="pre">univariate.to_pd()</span></code> will convert the <a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries" title="merlion.utils.time_series.UnivariateTimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">UnivariateTimeSeries</span></code></a>
into a regular <code class="docutils literal notranslate"><span class="pre">pd.Series</span></code> (for compatibility).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">univariate</span> <span class="pre">=</span> <span class="pre">UnivariateTimeSeries.from_pd(series)</span></code> uses a time-indexed
<code class="docutils literal notranslate"><span class="pre">pd.Series</span></code> to create a <a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries" title="merlion.utils.time_series.UnivariateTimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">UnivariateTimeSeries</span></code></a> object directly.</p></li>
</ol>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.time_series.UnivariateTimeSeries.__getitem__">
<span class="sig-name descname"><span class="pre">__getitem__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.time_series.UnivariateTimeSeries.__getitem__" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>i</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">slice</span></code>]) – integer index or slice</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>Union[Tuple[float, float], <a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries" title="merlion.utils.time_series.UnivariateTimeSeries">UnivariateTimeSeries</a>]</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">(self.time_stamps[i],</span> <span class="pre">self.values[i])</span></code> if <code class="docutils literal notranslate"><span class="pre">i</span></code> is
an integer. <code class="docutils literal notranslate"><span class="pre">UnivariateTimeSeries(self.time_series[i],</span> <span class="pre">self.values[i])</span></code>
if <code class="docutils literal notranslate"><span class="pre">i</span></code> is a slice.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.time_series.UnivariateTimeSeries.__iter__">
<span class="sig-name descname"><span class="pre">__iter__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.time_series.UnivariateTimeSeries.__iter__" title="Permalink to this definition"></a></dt>
<dd><p>The i’th item in the iterator is the tuple
<code class="docutils literal notranslate"><span class="pre">(self.time_stamps[i],</span> <span class="pre">self.values[i])</span></code>.</p>
</dd></dl>

<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>time_stamps</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code>[<code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]]]) – a sequence of Unix timestamps. You may specify
<code class="docutils literal notranslate"><span class="pre">None</span></code> if you only have <code class="docutils literal notranslate"><span class="pre">values</span></code> with no specific time stamps.</p></li>
<li><p><strong>values</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]) – a sequence of univariate values, where <code class="docutils literal notranslate"><span class="pre">values[i]</span></code>
occurs at time <code class="docutils literal notranslate"><span class="pre">time_stamps[i]</span></code></p></li>
<li><p><strong>name</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]) – the name of the univariate time series</p></li>
<li><p><strong>freq</strong> – if <code class="docutils literal notranslate"><span class="pre">time_stamps</span></code> is not provided, the univariate is
assumed to be sampled at frequency <code class="docutils literal notranslate"><span class="pre">freq</span></code>. <code class="docutils literal notranslate"><span class="pre">freq</span></code> may be a
string (e.g. <code class="docutils literal notranslate"><span class="pre">&quot;1h&quot;</span></code>), timedelta, or <code class="docutils literal notranslate"><span class="pre">int</span></code>/<code class="docutils literal notranslate"><span class="pre">float</span></code> (in units
of seconds).</p></li>
</ul>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="merlion.utils.time_series.UnivariateTimeSeries.np_time_stamps">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">np_time_stamps</span></span><a class="headerlink" href="#merlion.utils.time_series.UnivariateTimeSeries.np_time_stamps" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the <code class="docutils literal notranslate"><span class="pre">numpy</span></code> representation of this time series’s Unix timestamps</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="merlion.utils.time_series.UnivariateTimeSeries.np_values">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">np_values</span></span><a class="headerlink" href="#merlion.utils.time_series.UnivariateTimeSeries.np_values" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the <code class="docutils literal notranslate"><span class="pre">numpy</span></code> representation of this time series’s values</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="merlion.utils.time_series.UnivariateTimeSeries.time_stamps">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">time_stamps</span></span><a class="headerlink" href="#merlion.utils.time_series.UnivariateTimeSeries.time_stamps" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>List[float]</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the list of Unix timestamps for the time series</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="merlion.utils.time_series.UnivariateTimeSeries.values">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">values</span></span><a class="headerlink" href="#merlion.utils.time_series.UnivariateTimeSeries.values" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>List[float]</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the list of values for the time series.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="merlion.utils.time_series.UnivariateTimeSeries.t0">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">t0</span></span><a class="headerlink" href="#merlion.utils.time_series.UnivariateTimeSeries.t0" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the first timestamp in the univariate time series.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="merlion.utils.time_series.UnivariateTimeSeries.tf">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">tf</span></span><a class="headerlink" href="#merlion.utils.time_series.UnivariateTimeSeries.tf" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the final timestamp in the univariate time series.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.time_series.UnivariateTimeSeries.is_empty">
<span class="sig-name descname"><span class="pre">is_empty</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.time_series.UnivariateTimeSeries.is_empty" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if the univariate is empty, False if not.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.time_series.UnivariateTimeSeries.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">deep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.time_series.UnivariateTimeSeries.copy" title="Permalink to this definition"></a></dt>
<dd><p>Copies the <a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries" title="merlion.utils.time_series.UnivariateTimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">UnivariateTimeSeries</span></code></a>. Simply a wrapper around the
<code class="docutils literal notranslate"><span class="pre">pd.Series.copy()</span></code> method.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.time_series.UnivariateTimeSeries.concat">
<span class="sig-name descname"><span class="pre">concat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.time_series.UnivariateTimeSeries.concat" title="Permalink to this definition"></a></dt>
<dd><p>Concatenates the <a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries" title="merlion.utils.time_series.UnivariateTimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">UnivariateTimeSeries</span></code></a> <code class="docutils literal notranslate"><span class="pre">other</span></code> to the right of this one.
:param UnivariateTimeSeries other: another <a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries" title="merlion.utils.time_series.UnivariateTimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">UnivariateTimeSeries</span></code></a>
:rtype: UnivariateTimeSeries
:return: concatenated univariate time series</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.time_series.UnivariateTimeSeries.bisect">
<span class="sig-name descname"><span class="pre">bisect</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t_in_left</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.time_series.UnivariateTimeSeries.bisect" title="Permalink to this definition"></a></dt>
<dd><p>Splits the time series at the point where the given timestamp occurs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – a Unix timestamp or datetime object. Everything before time
<code class="docutils literal notranslate"><span class="pre">t</span></code> is in the left split, and everything after time <code class="docutils literal notranslate"><span class="pre">t</span></code> is in
the right split.</p></li>
<li><p><strong>t_in_left</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – if <code class="docutils literal notranslate"><span class="pre">True</span></code>, <code class="docutils literal notranslate"><span class="pre">t</span></code> is in the left split. Otherwise,
<code class="docutils literal notranslate"><span class="pre">t</span></code> is in the right split.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>Tuple[<a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries" title="merlion.utils.time_series.UnivariateTimeSeries">UnivariateTimeSeries</a>, <a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries" title="merlion.utils.time_series.UnivariateTimeSeries">UnivariateTimeSeries</a>]</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the left and right splits of the time series.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.time_series.UnivariateTimeSeries.window">
<span class="sig-name descname"><span class="pre">window</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_tf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.time_series.UnivariateTimeSeries.window" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t0</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – The timestamp/datetime at the start of the window (inclusive)</p></li>
<li><p><strong>tf</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – The timestamp/datetime at the end of the window (inclusive
if <code class="docutils literal notranslate"><span class="pre">include_tf</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, non-inclusive otherwise)</p></li>
<li><p><strong>include_tf</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – Whether to include <code class="docutils literal notranslate"><span class="pre">tf</span></code> in the window.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries" title="merlion.utils.time_series.UnivariateTimeSeries">UnivariateTimeSeries</a></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The subset of the time series occurring between timestamps
<code class="docutils literal notranslate"><span class="pre">t0</span></code> (inclusive) and <code class="docutils literal notranslate"><span class="pre">tf</span></code> (included if <code class="docutils literal notranslate"><span class="pre">include_tf</span></code> is
<code class="docutils literal notranslate"><span class="pre">True</span></code>, excluded otherwise).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.time_series.UnivariateTimeSeries.to_dict">
<span class="sig-name descname"><span class="pre">to_dict</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.time_series.UnivariateTimeSeries.to_dict" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Dict</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A dictionary representing the data points in the time series.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.time_series.UnivariateTimeSeries.from_dict">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_dict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.time_series.UnivariateTimeSeries.from_dict" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Dict</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]) – A dictionary of timestamp - value pairs</p></li>
<li><p><strong>name</strong> – the name to assign the output</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries" title="merlion.utils.time_series.UnivariateTimeSeries">UnivariateTimeSeries</a></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the <a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries" title="merlion.utils.time_series.UnivariateTimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">UnivariateTimeSeries</span></code></a> represented by series.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.time_series.UnivariateTimeSeries.to_pd">
<span class="sig-name descname"><span class="pre">to_pd</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.time_series.UnivariateTimeSeries.to_pd" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A pandas Series representing the time series, indexed by time.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.time_series.UnivariateTimeSeries.from_pd">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_pd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">series</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'1h'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.time_series.UnivariateTimeSeries.from_pd" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>series</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code>]) – a <code class="docutils literal notranslate"><span class="pre">pd.Series</span></code>. If it has a``pd.DatetimeIndex``, we will use that index for the timestamps.
Otherwise, we will create one at the specified frequency.</p></li>
<li><p><strong>name</strong> – the name to assign the output</p></li>
<li><p><strong>freq</strong> – if <code class="docutils literal notranslate"><span class="pre">series</span></code> is not indexed by time, this is the frequency at which we will assume it is sampled.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries" title="merlion.utils.time_series.UnivariateTimeSeries">UnivariateTimeSeries</a></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the <a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries" title="merlion.utils.time_series.UnivariateTimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">UnivariateTimeSeries</span></code></a> represented by series.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.time_series.UnivariateTimeSeries.to_ts">
<span class="sig-name descname"><span class="pre">to_ts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.time_series.UnivariateTimeSeries.to_ts" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Name</dt>
<dd class="field-odd"><p>a name to assign the univariate when converting it to a time series. Can override the existing name.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries">TimeSeries</a></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A <a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a> representing this univariate time series.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.time_series.UnivariateTimeSeries.empty">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">empty</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.time_series.UnivariateTimeSeries.empty" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries" title="merlion.utils.time_series.UnivariateTimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">UnivariateTimeSeries</span></code></a></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A Merlion <a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries" title="merlion.utils.time_series.UnivariateTimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">UnivariateTimeSeries</span></code></a> that has empty timestamps and values.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="merlion.utils.time_series.TimeSeries">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">merlion.utils.time_series.</span></span><span class="sig-name descname"><span class="pre">TimeSeries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">univariates</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_aligned</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.time_series.TimeSeries" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Please read the <a class="reference internal" href="tutorials/TimeSeries.html"><span class="doc">tutorial</span></a> before reading this API doc.
This class represents a general multivariate time series as a wrapper around
a number of (optionally named) <a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries" title="merlion.utils.time_series.UnivariateTimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">UnivariateTimeSeries</span></code></a>. A <a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a> object
is initialized as <code class="docutils literal notranslate"><span class="pre">time_series</span> <span class="pre">=</span> <span class="pre">TimeSeries(univariates)</span></code>, where
<code class="docutils literal notranslate"><span class="pre">univariates</span></code> is either a list of <a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries" title="merlion.utils.time_series.UnivariateTimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">UnivariateTimeSeries</span></code></a>, or a dictionary
mapping string names to their corresponding <a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries" title="merlion.utils.time_series.UnivariateTimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">UnivariateTimeSeries</span></code></a> objects.</p>
<p>Because the individual <code class="docutils literal notranslate"><span class="pre">univariates</span></code> need not be sampled at the same times, an
important concept for <a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a> is <em>alignment</em>. We say that a <a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a>
is <em>aligned</em> if all of its univariates have observations sampled at the exact
set set of times.</p>
<p>One may access the <a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries" title="merlion.utils.time_series.UnivariateTimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">UnivariateTimeSeries</span></code></a> comprising this <a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a> in
four ways:</p>
<ol class="arabic">
<li><p>Iterate over the individual univariates using</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">time_series</span><span class="o">.</span><span class="n">univariates</span><span class="p">:</span>
    <span class="c1"># do stuff with each UnivariateTimeSeries var</span>
</pre></div>
</div>
</li>
<li><p>Access an individual <a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries" title="merlion.utils.time_series.UnivariateTimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">UnivariateTimeSeries</span></code></a> by name as
<code class="docutils literal notranslate"><span class="pre">time_series.univariates[name]</span></code>. If you supplied unnamed univariates to
the constructor (i.e. using a list), the name of a univariate will just
be its index in that list.</p></li>
<li><p>Get the list of each univariate’s name with <code class="docutils literal notranslate"><span class="pre">time_series.names</span></code>.</p></li>
<li><p>Iterate over named univariates as</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">time_series</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="c1"># do stuff</span>
</pre></div>
</div>
<p>Note that this is equivalent to iterating over
<code class="docutils literal notranslate"><span class="pre">zip(time_series.names,</span> <span class="pre">time_series.univariates)</span></code>.</p>
</li>
</ol>
<p>This class supports the following additional features as well:</p>
<ol class="arabic">
<li><p>Interoperability with <code class="docutils literal notranslate"><span class="pre">pandas</span></code></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">df</span> <span class="pre">=</span> <span class="pre">time_series.to_pd()</span></code> yields a time-indexed <code class="docutils literal notranslate"><span class="pre">pd.DataFrame</span></code>,
where each column (with the appropriate name) corresponds to a
variable. Missing values are <code class="docutils literal notranslate"><span class="pre">NaN</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">time_series</span> <span class="pre">=</span> <span class="pre">TimeSeries.from_pd(df)</span></code> takes a time-indexed
<code class="docutils literal notranslate"><span class="pre">pd.DataFrame</span></code> and returns a corresponding <a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a> object
(missing values are handled appropriately). The order of
<code class="docutils literal notranslate"><span class="pre">time_series.univariates</span></code> is the order of <code class="docutils literal notranslate"><span class="pre">df.keys()</span></code>.</p></li>
</ul>
</li>
<li><p>Automated alignment: <code class="docutils literal notranslate"><span class="pre">aligned</span> <span class="pre">=</span> <span class="pre">time_series.align()</span></code> resamples each of
<code class="docutils literal notranslate"><span class="pre">time_series.univariates</span></code> so that they all have the same timestamps.
By default, this is done by taking the union of all timestamps present
in any individual univariate time series, and imputing missing values
via interpolation. See the method documentation for details on how you
may configure the alignment policy.</p></li>
<li><p>Transparent indexing and iteration for <a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a> which have all
univariates aligned (i.e. they all have the same timestamps)</p>
<ul>
<li><p>Get the length and shape of the time series (equal to the number of
observations in each individual univariate). Note that if the time
series is not aligned, we will return the length/shape of an equivalent
<code class="docutils literal notranslate"><span class="pre">pandas</span></code> dataframe and emit a warning.</p></li>
<li><p>Index <code class="docutils literal notranslate"><span class="pre">time_series[i]</span> <span class="pre">=</span> <span class="pre">(times[i],</span> <span class="pre">(x1[i],</span> <span class="pre">...,</span> <span class="pre">xn[i]))</span></code>
(assuming <code class="docutils literal notranslate"><span class="pre">time_series</span></code> has <code class="docutils literal notranslate"><span class="pre">n</span></code> aligned univariates with timestamps
<code class="docutils literal notranslate"><span class="pre">times</span></code>, and <code class="docutils literal notranslate"><span class="pre">xk</span> <span class="pre">=</span> <span class="pre">time_series.univariates[k-1].values</span></code>). Slice
returns a <a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a> object and works as one would expect.</p></li>
<li><p>Assuming <code class="docutils literal notranslate"><span class="pre">time_series</span></code> has <code class="docutils literal notranslate"><span class="pre">n</span></code> variables, you may iterate with</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">t_i</span><span class="p">,</span> <span class="p">(</span><span class="n">x1_i</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">xn_i</span><span class="p">)</span> <span class="ow">in</span> <span class="n">time_series</span><span class="p">:</span>
    <span class="c1"># do stuff</span>
</pre></div>
</div>
<p>Notably, this lets you call <code class="docutils literal notranslate"><span class="pre">times,</span> <span class="pre">val_vectors</span> <span class="pre">=</span> <span class="pre">zip(*time_series)</span></code></p>
</li>
</ul>
</li>
<li><p>Time-based queries for any time series</p>
<ul class="simple">
<li><p>Get the two sub <a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a> before and after a timestamp <code class="docutils literal notranslate"><span class="pre">t</span></code> via
<code class="docutils literal notranslate"><span class="pre">left,</span> <span class="pre">right</span> <span class="pre">=</span> <span class="pre">time_series.bisect(t)</span></code></p></li>
<li><p>Get the sub <a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a> between timestamps <code class="docutils literal notranslate"><span class="pre">t0</span></code> (inclusive) and
<code class="docutils literal notranslate"><span class="pre">tf</span></code> (non-inclusive) via <code class="docutils literal notranslate"><span class="pre">window</span> <span class="pre">=</span> <span class="pre">time_series.window(t0,</span> <span class="pre">tf)</span></code></p></li>
</ul>
</li>
<li><p>Concatenation: two <a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a> may be concatenated (in time) as
<code class="docutils literal notranslate"><span class="pre">time_series</span> <span class="pre">=</span> <span class="pre">time_series_1</span> <span class="pre">+</span> <span class="pre">time_series_2</span></code>.</p></li>
</ol>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.time_series.TimeSeries.__getitem__">
<span class="sig-name descname"><span class="pre">__getitem__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.time_series.TimeSeries.__getitem__" title="Permalink to this definition"></a></dt>
<dd><p>Only supported if all individual variable time series are sampled at the
same time stamps.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>i</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">slice</span></code>]) – integer index or slice.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>Union[Tuple[float, Tuple[float]], <a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries">TimeSeries</a>]</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>If <code class="docutils literal notranslate"><span class="pre">i</span></code> is an integer, returns the tuple
<code class="docutils literal notranslate"><span class="pre">(time_stamps[i],</span> <span class="pre">tuple(var.values[i]</span> <span class="pre">for</span> <span class="pre">var</span> <span class="pre">in</span> <span class="pre">self.univariates))</span></code>.
If <code class="docutils literal notranslate"><span class="pre">i</span></code> is a slice, returns the time series
<code class="docutils literal notranslate"><span class="pre">TimeSeries([var[i]</span> <span class="pre">for</span> <span class="pre">var</span> <span class="pre">in</span> <span class="pre">self.univariates])</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.time_series.TimeSeries.__iter__">
<span class="sig-name descname"><span class="pre">__iter__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.time_series.TimeSeries.__iter__" title="Permalink to this definition"></a></dt>
<dd><p>Only supported if all individual variable time series are sampled at the
same time stamps. The i’th item of the iterator is the tuple
<code class="docutils literal notranslate"><span class="pre">(time_stamps[i],</span> <span class="pre">tuple(var.values[i]</span> <span class="pre">for</span> <span class="pre">var</span> <span class="pre">in</span> <span class="pre">self.univariates))</span></code>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="merlion.utils.time_series.TimeSeries.names">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">names</span></span><a class="headerlink" href="#merlion.utils.time_series.TimeSeries.names" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The list of the names of the univariates.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.time_series.TimeSeries.items">
<span class="sig-name descname"><span class="pre">items</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.time_series.TimeSeries.items" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Iterator over <code class="docutils literal notranslate"><span class="pre">(name,</span> <span class="pre">univariate)</span></code> tuples.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="merlion.utils.time_series.TimeSeries.dim">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dim</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">int</span></em><a class="headerlink" href="#merlion.utils.time_series.TimeSeries.dim" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The dimension of the time series (the number of variables).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.time_series.TimeSeries.rename">
<span class="sig-name descname"><span class="pre">rename</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mapper</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.time_series.TimeSeries.rename" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>mapper</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>], <code class="xref py py-class docutils literal notranslate"><span class="pre">Mapping</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>], <code class="xref py py-data docutils literal notranslate"><span class="pre">Callable</span></code>[[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>], <code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]]) – Dict-like or function transformations to apply to the univariate names. Can also be an iterable
of new univariate names.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the time series with renamed univariates.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="merlion.utils.time_series.TimeSeries.is_aligned">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_aligned</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">bool</span></em><a class="headerlink" href="#merlion.utils.time_series.TimeSeries.is_aligned" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Whether all individual variable time series are sampled at the same time stamps, i.e. they are aligned.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="merlion.utils.time_series.TimeSeries.np_time_stamps">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">np_time_stamps</span></span><a class="headerlink" href="#merlion.utils.time_series.TimeSeries.np_time_stamps" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the <code class="docutils literal notranslate"><span class="pre">numpy</span></code> representation of this time series’s Unix timestamps</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="merlion.utils.time_series.TimeSeries.time_stamps">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">time_stamps</span></span><a class="headerlink" href="#merlion.utils.time_series.TimeSeries.time_stamps" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>List[float]</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the list of Unix timestamps for the time series</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="merlion.utils.time_series.TimeSeries.t0">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">t0</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">float</span></em><a class="headerlink" href="#merlion.utils.time_series.TimeSeries.t0" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the first timestamp in the time series.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="merlion.utils.time_series.TimeSeries.tf">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">tf</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">float</span></em><a class="headerlink" href="#merlion.utils.time_series.TimeSeries.tf" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the final timestamp in the time series.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.time_series.TimeSeries.is_empty">
<span class="sig-name descname"><span class="pre">is_empty</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.time_series.TimeSeries.is_empty" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>whether the time series is empty</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.time_series.TimeSeries.squeeze">
<span class="sig-name descname"><span class="pre">squeeze</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.time_series.TimeSeries.squeeze" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries" title="merlion.utils.time_series.UnivariateTimeSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">UnivariateTimeSeries</span></code></a></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a <a class="reference internal" href="#merlion.utils.time_series.UnivariateTimeSeries" title="merlion.utils.time_series.UnivariateTimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">UnivariateTimeSeries</span></code></a> if the time series only
has one univariate, otherwise returns itself, a <a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="merlion.utils.time_series.TimeSeries.shape">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">shape</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#merlion.utils.time_series.TimeSeries.shape" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the shape of this time series, i.e. <code class="docutils literal notranslate"><span class="pre">(self.dim,</span> <span class="pre">len(self))</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.time_series.TimeSeries.bisect">
<span class="sig-name descname"><span class="pre">bisect</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t_in_left</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.time_series.TimeSeries.bisect" title="Permalink to this definition"></a></dt>
<dd><p>Splits the time series at the point where the given timestamp <code class="docutils literal notranslate"><span class="pre">t</span></code> occurs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – a Unix timestamp or datetime object. Everything before time
<code class="docutils literal notranslate"><span class="pre">t</span></code> is in the left split, and everything after time <code class="docutils literal notranslate"><span class="pre">t</span></code> is in
the right split.</p></li>
<li><p><strong>t_in_left</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – if <code class="docutils literal notranslate"><span class="pre">True</span></code>, <code class="docutils literal notranslate"><span class="pre">t</span></code> is in the left split. Otherwise,
<code class="docutils literal notranslate"><span class="pre">t</span></code> is in the right split.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>Tuple[<a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries">TimeSeries</a>, <a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries">TimeSeries</a>]</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the left and right splits of the time series.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.time_series.TimeSeries.window">
<span class="sig-name descname"><span class="pre">window</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_tf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.time_series.TimeSeries.window" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t0</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – The timestamp/datetime at the start of the window (inclusive)</p></li>
<li><p><strong>tf</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – The timestamp/datetime at the end of the window (inclusive
if <code class="docutils literal notranslate"><span class="pre">include_tf</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, non-inclusive otherwise)</p></li>
<li><p><strong>include_tf</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – Whether to include <code class="docutils literal notranslate"><span class="pre">tf</span></code> in the window.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The subset of the time series occurring between timestamps
<code class="docutils literal notranslate"><span class="pre">t0</span></code> (inclusive) and <code class="docutils literal notranslate"><span class="pre">tf</span></code> (included if <code class="docutils literal notranslate"><span class="pre">include_tf</span></code> is
<code class="docutils literal notranslate"><span class="pre">True</span></code>, excluded otherwise).</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.time_series.TimeSeries.to_pd">
<span class="sig-name descname"><span class="pre">to_pd</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.time_series.TimeSeries.to_pd" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A pandas DataFrame (indexed by time) which represents this time
series. Each variable corresponds to a column of the DataFrame.
Timestamps which are present for one variable but not another, are
represented with NaN.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.time_series.TimeSeries.to_csv">
<span class="sig-name descname"><span class="pre">to_csv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_name</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.time_series.TimeSeries.to_csv" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.time_series.TimeSeries.from_pd">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_pd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">df</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_times</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">drop_nan</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'1h'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.time_series.TimeSeries.from_pd" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>df</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>]) – A <code class="docutils literal notranslate"><span class="pre">pandas.DataFrame</span></code> with a <code class="docutils literal notranslate"><span class="pre">DatetimeIndex</span></code>. Each column corresponds to a different variable of
the time series, and the  key of column (in sorted order) give the relative order of those variables in
<code class="docutils literal notranslate"><span class="pre">self.univariates</span></code>. Missing values should be represented with <code class="docutils literal notranslate"><span class="pre">NaN</span></code>. May also be a <code class="docutils literal notranslate"><span class="pre">pandas.Series</span></code>
for single-variable time series.</p></li>
<li><p><strong>check_times</strong> – whether to check that all times in the index are unique (up to the millisecond) and sorted.</p></li>
<li><p><strong>drop_nan</strong> – whether to drop all <code class="docutils literal notranslate"><span class="pre">NaN</span></code> entries before creating the time series. Specifying <code class="docutils literal notranslate"><span class="pre">False</span></code> is
useful if you wish to impute the values on your own.</p></li>
<li><p><strong>freq</strong> – if <code class="docutils literal notranslate"><span class="pre">df</span></code> is not indexed by time, this is the frequency at which we will assume it is sampled.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries">TimeSeries</a></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the <a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a> object corresponding to <code class="docutils literal notranslate"><span class="pre">df</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.time_series.TimeSeries.from_ts_list">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_ts_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ts_list</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_aligned</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.time_series.TimeSeries.from_ts_list" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ts_list</strong> (<em>Iterable</em><em>[</em><a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><em>TimeSeries</em></a><em>]</em>) – iterable of time series we wish to
form a multivariate time series with</p></li>
<li><p><strong>check_aligned</strong> (<em>bool</em>) – whether to check if the output time series is
aligned</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries">TimeSeries</a></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A multivariate <a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a> created from all the time series in
the inputs.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.time_series.TimeSeries.align">
<span class="sig-name descname"><span class="pre">align</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reference</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">granularity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">remove_non_overlapping</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alignment_policy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">aggregation_policy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">AggregationPolicy.Mean</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">missing_value_policy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">MissingValuePolicy.Interpolate</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.time_series.TimeSeries.align" title="Permalink to this definition"></a></dt>
<dd><p>Aligns all the univariates comprising this multivariate time series so that they all have the same time stamps.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reference</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code>[<code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]]]) – A specific set of timestamps we want the resampled time series to contain. Required if
<code class="docutils literal notranslate"><span class="pre">alignment_policy</span></code> is <a class="reference internal" href="#merlion.utils.resample.AlignPolicy.FixedReference" title="merlion.utils.resample.AlignPolicy.FixedReference"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">AlignPolicy.FixedReference</span></code></a>. Overrides other alignment policies if specified.</p></li>
<li><p><strong>granularity</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>]) – The granularity (in seconds) of the resampled time time series. Defaults to the GCD time
difference between adjacent elements of <code class="docutils literal notranslate"><span class="pre">time_series</span></code> (otherwise). Ignored if <code class="docutils literal notranslate"><span class="pre">reference</span></code> is given or
<code class="docutils literal notranslate"><span class="pre">alignment_policy</span></code> is <a class="reference internal" href="#merlion.utils.resample.AlignPolicy.FixedReference" title="merlion.utils.resample.AlignPolicy.FixedReference"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">AlignPolicy.FixedReference</span></code></a>. Overrides other alignment policies if specified.</p></li>
<li><p><strong>origin</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]) – The first timestamp of the resampled time series. Only used if the alignment policy is
<a class="reference internal" href="#merlion.utils.resample.AlignPolicy.FixedGranularity" title="merlion.utils.resample.AlignPolicy.FixedGranularity"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">AlignPolicy.FixedGranularity</span></code></a>.</p></li>
<li><p><strong>remove_non_overlapping</strong> – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, we will only keep the portions of the univariates that overlap with
each other. For example, if we have 3 univariates which span timestamps [0, 3600], [60, 3660], and
[30, 3540], we will only keep timestamps in the range [60, 3540]. If <code class="docutils literal notranslate"><span class="pre">False</span></code>, we will keep all timestamps
produced by the resampling.</p></li>
<li><p><strong>alignment_policy</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<a class="reference internal" href="#merlion.utils.resample.AlignPolicy" title="merlion.utils.resample.AlignPolicy"><code class="xref py py-class docutils literal notranslate"><span class="pre">AlignPolicy</span></code></a>]) – <p>The policy we want to use to align the time series.</p>
<ul>
<li><p><a class="reference internal" href="#merlion.utils.resample.AlignPolicy.FixedReference" title="merlion.utils.resample.AlignPolicy.FixedReference"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">AlignPolicy.FixedReference</span></code></a> aligns each single-variable time
series to <code class="docutils literal notranslate"><span class="pre">reference</span></code>, a user-specified sequence of timestamps.</p></li>
<li><p><a class="reference internal" href="#merlion.utils.resample.AlignPolicy.FixedGranularity" title="merlion.utils.resample.AlignPolicy.FixedGranularity"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">AlignPolicy.FixedGranularity</span></code></a> resamples each single-variable time
series at the same granularity, aggregating windows and imputing
missing values as desired.</p></li>
<li><p><a class="reference internal" href="#merlion.utils.resample.AlignPolicy.OuterJoin" title="merlion.utils.resample.AlignPolicy.OuterJoin"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">AlignPolicy.OuterJoin</span></code></a> returns a time series with the union of
all timestamps present in any single-variable time series.</p></li>
<li><p><a class="reference internal" href="#merlion.utils.resample.AlignPolicy.InnerJoin" title="merlion.utils.resample.AlignPolicy.InnerJoin"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">AlignPolicy.InnerJoin</span></code></a> returns a time series with the intersection
of all timestamps present in all single-variable time series.</p></li>
</ul>
</p></li>
<li><p><strong>aggregation_policy</strong> (<a class="reference internal" href="#merlion.utils.resample.AggregationPolicy" title="merlion.utils.resample.AggregationPolicy"><code class="xref py py-class docutils literal notranslate"><span class="pre">AggregationPolicy</span></code></a>) – The policy used to aggregate windows of adjacent observations when downsampling.</p></li>
<li><p><strong>missing_value_policy</strong> (<a class="reference internal" href="#merlion.utils.resample.MissingValuePolicy" title="merlion.utils.resample.MissingValuePolicy"><code class="xref py py-class docutils literal notranslate"><span class="pre">MissingValuePolicy</span></code></a>) – The policy used to impute missing values created when upsampling.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries">TimeSeries</a></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The resampled multivariate time series.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="merlion.utils.time_series.assert_equal_timedeltas">
<span class="sig-prename descclassname"><span class="pre">merlion.utils.time_series.</span></span><span class="sig-name descname"><span class="pre">assert_equal_timedeltas</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_series</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timedelta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.time_series.assert_equal_timedeltas" title="Permalink to this definition"></a></dt>
<dd><p>Checks that all time deltas in the time series are equal, either to each
other, or a pre-specified timedelta (in seconds).</p>
</dd></dl>

</section>
<section id="module-merlion.utils.resample">
<span id="merlion-utils-resample-module"></span><h2>merlion.utils.resample module<a class="headerlink" href="#module-merlion.utils.resample" title="Permalink to this heading"></a></h2>
<p>Code for resampling time series.</p>
<dl class="py class">
<dt class="sig sig-object py" id="merlion.utils.resample.AlignPolicy">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">merlion.utils.resample.</span></span><span class="sig-name descname"><span class="pre">AlignPolicy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.resample.AlignPolicy" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Enum</span></code></p>
<p>Policies for aligning multiple univariate time series.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="merlion.utils.resample.AlignPolicy.OuterJoin">
<span class="sig-name descname"><span class="pre">OuterJoin</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">0</span></em><a class="headerlink" href="#merlion.utils.resample.AlignPolicy.OuterJoin" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="merlion.utils.resample.AlignPolicy.InnerJoin">
<span class="sig-name descname"><span class="pre">InnerJoin</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">1</span></em><a class="headerlink" href="#merlion.utils.resample.AlignPolicy.InnerJoin" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="merlion.utils.resample.AlignPolicy.FixedReference">
<span class="sig-name descname"><span class="pre">FixedReference</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">2</span></em><a class="headerlink" href="#merlion.utils.resample.AlignPolicy.FixedReference" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="merlion.utils.resample.AlignPolicy.FixedGranularity">
<span class="sig-name descname"><span class="pre">FixedGranularity</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">3</span></em><a class="headerlink" href="#merlion.utils.resample.AlignPolicy.FixedGranularity" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="merlion.utils.resample.AggregationPolicy">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">merlion.utils.resample.</span></span><span class="sig-name descname"><span class="pre">AggregationPolicy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.resample.AggregationPolicy" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Enum</span></code></p>
<p>Aggregation policies. Values are partial functions for
pandas.core.resample.Resampler methods.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="merlion.utils.resample.AggregationPolicy.Mean">
<span class="sig-name descname"><span class="pre">Mean</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">functools.partial(&lt;function</span> <span class="pre">AggregationPolicy.&lt;lambda&gt;&gt;)</span></em><a class="headerlink" href="#merlion.utils.resample.AggregationPolicy.Mean" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="merlion.utils.resample.AggregationPolicy.Sum">
<span class="sig-name descname"><span class="pre">Sum</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">functools.partial(&lt;function</span> <span class="pre">AggregationPolicy.&lt;lambda&gt;&gt;)</span></em><a class="headerlink" href="#merlion.utils.resample.AggregationPolicy.Sum" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="merlion.utils.resample.AggregationPolicy.Median">
<span class="sig-name descname"><span class="pre">Median</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">functools.partial(&lt;function</span> <span class="pre">AggregationPolicy.&lt;lambda&gt;&gt;)</span></em><a class="headerlink" href="#merlion.utils.resample.AggregationPolicy.Median" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="merlion.utils.resample.AggregationPolicy.First">
<span class="sig-name descname"><span class="pre">First</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">functools.partial(&lt;function</span> <span class="pre">AggregationPolicy.&lt;lambda&gt;&gt;)</span></em><a class="headerlink" href="#merlion.utils.resample.AggregationPolicy.First" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="merlion.utils.resample.AggregationPolicy.Last">
<span class="sig-name descname"><span class="pre">Last</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">functools.partial(&lt;function</span> <span class="pre">AggregationPolicy.&lt;lambda&gt;&gt;)</span></em><a class="headerlink" href="#merlion.utils.resample.AggregationPolicy.Last" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="merlion.utils.resample.AggregationPolicy.Min">
<span class="sig-name descname"><span class="pre">Min</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">functools.partial(&lt;function</span> <span class="pre">AggregationPolicy.&lt;lambda&gt;&gt;)</span></em><a class="headerlink" href="#merlion.utils.resample.AggregationPolicy.Min" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="merlion.utils.resample.AggregationPolicy.Max">
<span class="sig-name descname"><span class="pre">Max</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">functools.partial(&lt;function</span> <span class="pre">AggregationPolicy.&lt;lambda&gt;&gt;)</span></em><a class="headerlink" href="#merlion.utils.resample.AggregationPolicy.Max" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="merlion.utils.resample.MissingValuePolicy">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">merlion.utils.resample.</span></span><span class="sig-name descname"><span class="pre">MissingValuePolicy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.resample.MissingValuePolicy" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Enum</span></code></p>
<p>Missing value imputation policies. Values are partial functions for <code class="docutils literal notranslate"><span class="pre">pd.Series</span></code> methods.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="merlion.utils.resample.MissingValuePolicy.FFill">
<span class="sig-name descname"><span class="pre">FFill</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">functools.partial(&lt;function</span> <span class="pre">MissingValuePolicy.&lt;lambda&gt;&gt;)</span></em><a class="headerlink" href="#merlion.utils.resample.MissingValuePolicy.FFill" title="Permalink to this definition"></a></dt>
<dd><p>Fill gap with the first value before the gap.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="merlion.utils.resample.MissingValuePolicy.BFill">
<span class="sig-name descname"><span class="pre">BFill</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">functools.partial(&lt;function</span> <span class="pre">MissingValuePolicy.&lt;lambda&gt;&gt;)</span></em><a class="headerlink" href="#merlion.utils.resample.MissingValuePolicy.BFill" title="Permalink to this definition"></a></dt>
<dd><p>Fill gap with the first value after the gap.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="merlion.utils.resample.MissingValuePolicy.Nearest">
<span class="sig-name descname"><span class="pre">Nearest</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">functools.partial(&lt;function</span> <span class="pre">MissingValuePolicy.&lt;lambda&gt;&gt;,</span> <span class="pre">method='nearest')</span></em><a class="headerlink" href="#merlion.utils.resample.MissingValuePolicy.Nearest" title="Permalink to this definition"></a></dt>
<dd><p>Replace missing value with the value closest to it.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="merlion.utils.resample.MissingValuePolicy.Interpolate">
<span class="sig-name descname"><span class="pre">Interpolate</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">functools.partial(&lt;function</span> <span class="pre">MissingValuePolicy.&lt;lambda&gt;&gt;,</span> <span class="pre">method='time')</span></em><a class="headerlink" href="#merlion.utils.resample.MissingValuePolicy.Interpolate" title="Permalink to this definition"></a></dt>
<dd><p>Fill in missing values by linear interpolation.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="merlion.utils.resample.MissingValuePolicy.ZFill">
<span class="sig-name descname"><span class="pre">ZFill</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">functools.partial(&lt;function</span> <span class="pre">MissingValuePolicy.&lt;lambda&gt;&gt;,</span> <span class="pre">to_replace=nan,</span> <span class="pre">value=0)</span></em><a class="headerlink" href="#merlion.utils.resample.MissingValuePolicy.ZFill" title="Permalink to this definition"></a></dt>
<dd><p>Replace missing values with zeros.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="merlion.utils.resample.to_pd_datetime">
<span class="sig-prename descclassname"><span class="pre">merlion.utils.resample.</span></span><span class="sig-name descname"><span class="pre">to_pd_datetime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">timestamp</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.resample.to_pd_datetime" title="Permalink to this definition"></a></dt>
<dd><p>Converts a timestamp (or list/iterable of timestamps) to pandas Datetime, truncated at the millisecond.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="merlion.utils.resample.to_timestamp">
<span class="sig-prename descclassname"><span class="pre">merlion.utils.resample.</span></span><span class="sig-name descname"><span class="pre">to_timestamp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.resample.to_timestamp" title="Permalink to this definition"></a></dt>
<dd><p>Converts a datetime to a Unix timestamp.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="merlion.utils.resample.granularity_str_to_seconds">
<span class="sig-prename descclassname"><span class="pre">merlion.utils.resample.</span></span><span class="sig-name descname"><span class="pre">granularity_str_to_seconds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">granularity</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.resample.granularity_str_to_seconds" title="Permalink to this definition"></a></dt>
<dd><p>Converts a string/float/int granularity (representing a timedelta) to the
number of seconds it represents, truncated at the millisecond.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="merlion.utils.resample.get_gcd_timedelta">
<span class="sig-prename descclassname"><span class="pre">merlion.utils.resample.</span></span><span class="sig-name descname"><span class="pre">get_gcd_timedelta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">time_stamp_lists</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.resample.get_gcd_timedelta" title="Permalink to this definition"></a></dt>
<dd><p>Calculates all timedeltas present in any of the lists of time stamps given,
and returns the GCD of all these timedeltas (up to units of milliseconds).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="merlion.utils.resample.infer_granularity">
<span class="sig-prename descclassname"><span class="pre">merlion.utils.resample.</span></span><span class="sig-name descname"><span class="pre">infer_granularity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_stamps</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.resample.infer_granularity" title="Permalink to this definition"></a></dt>
<dd><p>Infers the granularity of a list of time stamps</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="merlion.utils.resample.reindex_df">
<span class="sig-prename descclassname"><span class="pre">merlion.utils.resample.</span></span><span class="sig-name descname"><span class="pre">reindex_df</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">df</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reference</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">missing_value_policy</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.resample.reindex_df" title="Permalink to this definition"></a></dt>
<dd><p>Reindexes a Datetime-indexed dataframe <code class="docutils literal notranslate"><span class="pre">df</span></code> to have the same time stamps
as a reference sequence of timestamps. Imputes missing values with the given
<a class="reference internal" href="#merlion.utils.resample.MissingValuePolicy" title="merlion.utils.resample.MissingValuePolicy"><code class="xref any py py-class docutils literal notranslate"><span class="pre">MissingValuePolicy</span></code></a>.</p>
</dd></dl>

</section>
<section id="module-merlion.utils.data_io">
<span id="merlion-utils-data-io-module"></span><h2>merlion.utils.data_io module<a class="headerlink" href="#module-merlion.utils.data_io" title="Permalink to this heading"></a></h2>
<p>Utils for data I/O.</p>
<dl class="py function">
<dt class="sig sig-object py" id="merlion.utils.data_io.df_to_time_series">
<span class="sig-prename descclassname"><span class="pre">merlion.utils.data_io.</span></span><span class="sig-name descname"><span class="pre">df_to_time_series</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">df</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_col</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timestamp_unit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'s'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_cols</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.data_io.df_to_time_series" title="Permalink to this definition"></a></dt>
<dd><p>Converts a general <code class="docutils literal notranslate"><span class="pre">pandas.DataFrame</span></code> to a <a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a> object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>df</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code>) – the dataframe to process</p></li>
<li><p><strong>time_col</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]) – the name of the column specifying time. If <code class="docutils literal notranslate"><span class="pre">None</span></code> is specified, the existing index
is used if it is a <code class="docutils literal notranslate"><span class="pre">DatetimeIndex</span></code>. Otherwise, the first column is used.</p></li>
<li><p><strong>timestamp_unit</strong> – if the time column is in Unix timestamps, this is the unit of the timestamp.</p></li>
<li><p><strong>data_cols</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>], <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>]) – the columns representing the actual data values of interest.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="merlion.utils.data_io.data_io_decorator">
<span class="sig-prename descclassname"><span class="pre">merlion.utils.data_io.</span></span><span class="sig-name descname"><span class="pre">data_io_decorator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.data_io.data_io_decorator" title="Permalink to this definition"></a></dt>
<dd><p>Decorator to standardize docstrings for data I/O functions.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="merlion.utils.data_io.csv_to_time_series">
<span class="sig-prename descclassname"><span class="pre">merlion.utils.data_io.</span></span><span class="sig-name descname"><span class="pre">csv_to_time_series</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_col</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timestamp_unit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'s'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_cols</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><span class="pre">TimeSeries</span></a></span></span><a class="headerlink" href="#merlion.utils.data_io.csv_to_time_series" title="Permalink to this definition"></a></dt>
<dd><p>Reads a CSV file and converts it to a <a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a> object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>time_col</strong> – the name of the column specifying time. If <code class="docutils literal notranslate"><span class="pre">None</span></code> is specified, the existing index
is used if it is a <code class="docutils literal notranslate"><span class="pre">DatetimeIndex</span></code>. Otherwise, the first column is used.</p></li>
<li><p><strong>timestamp_unit</strong> – if the time column is in Unix timestamps, this is the unit of the timestamp.</p></li>
<li><p><strong>data_cols</strong> – the columns representing the actual data values of interest.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-merlion.utils.hts">
<span id="merlion-utils-hts-module"></span><h2>merlion.utils.hts module<a class="headerlink" href="#module-merlion.utils.hts" title="Permalink to this heading"></a></h2>
<p>Aggregation for hierarchical time series.</p>
<dl class="py function">
<dt class="sig sig-object py" id="merlion.utils.hts.minT_reconciliation">
<span class="sig-prename descclassname"><span class="pre">merlion.utils.hts.</span></span><span class="sig-name descname"><span class="pre">minT_reconciliation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">forecasts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sum_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_leaves</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.hts.minT_reconciliation" title="Permalink to this definition"></a></dt>
<dd><p>Computes the minimum trace reconciliation for hierarchical time series, as described by
<a class="reference external" href="https://robjhyndman.com/papers/mint.pdf">Wickramasuriya et al. 2018</a>. This algorithm assumes that
we have a number of time series aggregated at various levels (the aggregation tree is described by <code class="docutils literal notranslate"><span class="pre">sum_matrix</span></code>),
and we obtain independent forecasts at each level of the hierarchy. Minimum trace reconciliation finds the optimal
way to adjust (reconcile) the forecasts to reduce the variance of the estimation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>forecasts</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a>]) – forecast for each aggregation level of the hierarchy</p></li>
<li><p><strong>errs</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a>]) – standard errors of forecasts for each level of the hierarchy. While not strictly necessary,
reconciliation performs better if all forecasts are accompanied by uncertainty estimates.</p></li>
<li><p><strong>sum_matrix</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – matrix describing how the hierarchy is aggregated</p></li>
<li><p><strong>n_leaves</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – the number of leaf forecasts (i.e. the number of forecasts at the most dis-aggregated level
of the hierarchy). We assume that the leaf forecasts are last in the lists <code class="docutils literal notranslate"><span class="pre">forecasts</span></code> &amp; <code class="docutils literal notranslate"><span class="pre">errs</span></code>,
and that <code class="docutils literal notranslate"><span class="pre">sum_matrix</span></code> reflects this fact.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a>]</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>reconciled forecasts for each aggregation level of the hierarchy</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-merlion.utils.ts_generator">
<span id="merlion-utils-ts-generator-module"></span><h2>merlion.utils.ts_generator module<a class="headerlink" href="#module-merlion.utils.ts_generator" title="Permalink to this heading"></a></h2>
<p>Generators for synthetic time series.</p>
<dl class="py class">
<dt class="sig sig-object py" id="merlion.utils.ts_generator.TimeSeriesGenerator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">merlion.utils.ts_generator.</span></span><span class="sig-name descname"><span class="pre">TimeSeriesGenerator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x0=0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step=1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale=1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noise=&lt;built-in</span> <span class="pre">method</span> <span class="pre">normal</span> <span class="pre">of</span> <span class="pre">numpy.random.mtrand.RandomState</span> <span class="pre">object&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distort=&lt;built-in</span> <span class="pre">function</span> <span class="pre">add&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t0='1970</span> <span class="pre">00:00:00'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tdelta='5min'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.ts_generator.TimeSeriesGenerator" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>An abstract base class for generating synthetic time series data.
Generates a 1-dimensional grid x(0), x(1), …, x(n-1), where x(i) = x0 + i * step.
Then generates a time series y(0), y(1), …, y(n-1), where y(i) = f(x(i)) + noise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – The number of points to be generated.</p></li>
<li><p><strong>x0</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – The initial value to use to form that 1-dimensional grid that
will be used to compute the synthetic values.</p></li>
<li><p><strong>step</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – The step size to use when forming the 1-dimensional grid.</p></li>
<li><p><strong>scale</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – A scalar to use to either inflate or deflate the synthetic data.</p></li>
<li><p><strong>noise</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Callable</span></code>[[], <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]) – A function that generates a random value when called.</p></li>
<li><p><strong>distort</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Callable</span></code>[[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>], <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]) – A function mapping two real numbers to one real number which will
be used to inject noise into the time series.</p></li>
<li><p><strong>name</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]) – The name to assign the univariate that will be generated.</p></li>
<li><p><strong>t0</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – Initial timestamp to use when wrapping the generated values into a
TimeSeries object.</p></li>
<li><p><strong>tdelta</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – the time delta to use when wrapping the generated values into a
TimeSeries object.</p></li>
</ul>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="merlion.utils.ts_generator.TimeSeriesGenerator.n">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">n</span></span><a class="headerlink" href="#merlion.utils.ts_generator.TimeSeriesGenerator.n" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="merlion.utils.ts_generator.TimeSeriesGenerator.x0">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">x0</span></span><a class="headerlink" href="#merlion.utils.ts_generator.TimeSeriesGenerator.x0" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="merlion.utils.ts_generator.TimeSeriesGenerator.step">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">step</span></span><a class="headerlink" href="#merlion.utils.ts_generator.TimeSeriesGenerator.step" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.ts_generator.TimeSeriesGenerator.y">
<span class="sig-name descname"><span class="pre">y</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.ts_generator.TimeSeriesGenerator.y" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.ts_generator.TimeSeriesGenerator.generate">
<span class="sig-name descname"><span class="pre">generate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">return_ts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.ts_generator.TimeSeriesGenerator.generate" title="Permalink to this definition"></a></dt>
<dd><p>Generates synthetic time series data according and returns it as a list or as a
TimeSeries object.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>], <a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a>]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="merlion.utils.ts_generator.GeneratorComposer">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">merlion.utils.ts_generator.</span></span><span class="sig-name descname"><span class="pre">GeneratorComposer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">generators</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">per_generator_noise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.ts_generator.GeneratorComposer" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#merlion.utils.ts_generator.TimeSeriesGenerator" title="merlion.utils.ts_generator.TimeSeriesGenerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeSeriesGenerator</span></code></a></p>
<p>A class for generating synthetic time series by composing
other TimeSeriesGenerator’s.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> – The number of points to be generated.</p></li>
<li><p><strong>x0</strong> – The initial value to use to form that 1-dimensional grid that
will be used to compute the synthetic values.</p></li>
<li><p><strong>step</strong> – The step size to use when forming the 1-dimensional grid.</p></li>
<li><p><strong>scale</strong> – A scalar to use to either inflate or deflate the synthetic data.</p></li>
<li><p><strong>noise</strong> – A function that generates a random value when called.</p></li>
<li><p><strong>distort</strong> – A function mapping two real numbers to one real number which will
be used to inject noise into the time series.</p></li>
<li><p><strong>name</strong> – The name to assign the univariate that will be generated.</p></li>
<li><p><strong>t0</strong> – Initial timestamp to use when wrapping the generated values into a
TimeSeries object.</p></li>
<li><p><strong>tdelta</strong> – the time delta to use when wrapping the generated values into a
TimeSeries object.</p></li>
</ul>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="merlion.utils.ts_generator.GeneratorComposer.generators">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">generators</span></span><a class="headerlink" href="#merlion.utils.ts_generator.GeneratorComposer.generators" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="merlion.utils.ts_generator.GeneratorConcatenator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">merlion.utils.ts_generator.</span></span><span class="sig-name descname"><span class="pre">GeneratorConcatenator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string_outputs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.ts_generator.GeneratorConcatenator" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#merlion.utils.ts_generator.GeneratorComposer" title="merlion.utils.ts_generator.GeneratorComposer"><code class="xref py py-class docutils literal notranslate"><span class="pre">GeneratorComposer</span></code></a></p>
<p>A class for generating synthetic time series data that undergoes
fundamental changes to it’s behavior that certain points in time.
For example, with this class one could generate a time series that begins
as linear and then becomes stationary.</p>
<p>For example, let f = 0 with for 3 steps 0,1,2 and g = 2 * x for the next three
steps 3,4,5. generate() returns:</p>
<ul class="simple">
<li><p>[0, 0, 0, 6, 8, 10] if string_outputs is False</p></li>
<li><p>[0, 0, 0, 2, 4, 6]  if string_outputs is True.</p></li>
</ul>
<dl class="simple">
<dt>param string_outputs: If True, ensure that the end and beginning of each</dt><dd><p>pair of consecutive time series are connected. For example, Let there be
two generating functions f, and g belonging to consecutive generators. If
True, adjust g by a constant c such that f(x) = g(x) at the last point x
that f uses to generate its series.</p>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="merlion.utils.ts_generator.GeneratorConcatenator.generators">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">generators</span></span><a class="headerlink" href="#merlion.utils.ts_generator.GeneratorConcatenator.generators" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.ts_generator.GeneratorConcatenator.y">
<span class="sig-name descname"><span class="pre">y</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.ts_generator.GeneratorConcatenator.y" title="Permalink to this definition"></a></dt>
<dd><p>A Generator Sequence has no method <a class="reference internal" href="#merlion.utils.ts_generator.GeneratorConcatenator.y" title="merlion.utils.ts_generator.GeneratorConcatenator.y"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">y</span></code></a>.</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-merlion.utils.conj_priors">
<span id="merlion-utils-conj-priors-module"></span><h2>merlion.utils.conj_priors module<a class="headerlink" href="#module-merlion.utils.conj_priors" title="Permalink to this heading"></a></h2>
<p>Implementations of Bayesian conjugate priors &amp; their online update rules.</p>
<table class="autosummary longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#merlion.utils.conj_priors.ConjPrior" title="merlion.utils.conj_priors.ConjPrior"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ConjPrior</span></code></a>([sample])</p></td>
<td><p>Abstract base class for a Bayesian conjugate prior.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#merlion.utils.conj_priors.BetaBernoulli" title="merlion.utils.conj_priors.BetaBernoulli"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BetaBernoulli</span></code></a>([sample])</p></td>
<td><p>Beta-Bernoulli conjugate prior for binary data.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#merlion.utils.conj_priors.NormInvGamma" title="merlion.utils.conj_priors.NormInvGamma"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NormInvGamma</span></code></a>([sample])</p></td>
<td><p>Normal-InverseGamma conjugate prior.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#merlion.utils.conj_priors.MVNormInvWishart" title="merlion.utils.conj_priors.MVNormInvWishart"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MVNormInvWishart</span></code></a>([sample])</p></td>
<td><p>Multivariate Normal-InverseWishart conjugate prior.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#merlion.utils.conj_priors.BayesianLinReg" title="merlion.utils.conj_priors.BayesianLinReg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BayesianLinReg</span></code></a>([sample])</p></td>
<td><p>Bayesian Ordinary Linear Regression conjugate prior, which models a univariate input as a function of time.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#merlion.utils.conj_priors.BayesianMVLinReg" title="merlion.utils.conj_priors.BayesianMVLinReg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BayesianMVLinReg</span></code></a>([sample])</p></td>
<td><p>Bayesian multivariate linear regression conjugate prior, which models a multivariate input as a function of time.</p></td>
</tr>
</tbody>
</table>
<dl class="py class">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.ConjPrior">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">merlion.utils.conj_priors.</span></span><span class="sig-name descname"><span class="pre">ConjPrior</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sample</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.ConjPrior" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">ABC</span></code></p>
<p>Abstract base class for a Bayesian conjugate prior.
Can be used with either <a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref any py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a> or <code class="docutils literal notranslate"><span class="pre">numpy</span></code> arrays directly.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>sample</strong> – a sample used to initialize the prior.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.ConjPrior.to_dict">
<span class="sig-name descname"><span class="pre">to_dict</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.ConjPrior.to_dict" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.ConjPrior.from_dict">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_dict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state_dict</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.ConjPrior.from_dict" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.ConjPrior.get_time_series_values">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_time_series_values</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.ConjPrior.get_time_series_values" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>numpy array representing the input <code class="docutils literal notranslate"><span class="pre">x</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.ConjPrior.process_time_series">
<span class="sig-name descname"><span class="pre">process_time_series</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.ConjPrior.process_time_series" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>]</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">(t,</span> <span class="pre">x)</span></code>, where <code class="docutils literal notranslate"><span class="pre">t</span></code> is a normalized list of timestamps, and <code class="docutils literal notranslate"><span class="pre">x</span></code> is a <code class="docutils literal notranslate"><span class="pre">numpy</span></code> array
representing the input</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.ConjPrior.posterior">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">posterior</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_rv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_updated</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.ConjPrior.posterior" title="Permalink to this definition"></a></dt>
<dd><p>Predictive posterior (log) PDF for new observations, or the <code class="docutils literal notranslate"><span class="pre">scipy.stats</span></code> random variable where applicable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – value(s) to evaluate posterior at (<code class="docutils literal notranslate"><span class="pre">None</span></code> implies that we want to return the random variable)</p></li>
<li><p><strong>return_rv</strong> – whether to return the random variable directly</p></li>
<li><p><strong>log</strong> – whether to return the log PDF (instead of the PDF)</p></li>
<li><p><strong>return_updated</strong> – whether to return an updated version of the conjugate prior as well</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.ConjPrior.update">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.ConjPrior.update" title="Permalink to this definition"></a></dt>
<dd><p>Update the conjugate prior based on new observations x.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.ConjPrior.forecast">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">forecast</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_stamps</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.ConjPrior.forecast" title="Permalink to this definition"></a></dt>
<dd><p>Return a posterior predictive interval for the time stamps given.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>time_stamps</strong> – a list of time stamps</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code>[<a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a>, <a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a>]</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">(forecast,</span> <span class="pre">stderr)</span></code>, where <code class="docutils literal notranslate"><span class="pre">forecast</span></code> is the expected posterior value and <code class="docutils literal notranslate"><span class="pre">stderr</span></code> is the
standard error of that forecast.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.ScalarConjPrior">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">merlion.utils.conj_priors.</span></span><span class="sig-name descname"><span class="pre">ScalarConjPrior</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sample</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.ScalarConjPrior" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#merlion.utils.conj_priors.ConjPrior" title="merlion.utils.conj_priors.ConjPrior"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConjPrior</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ABC</span></code></p>
<p>Abstract base class for a Bayesian conjugate prior for a scalar random variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>sample</strong> – a sample used to initialize the prior.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.ScalarConjPrior.process_time_series">
<span class="sig-name descname"><span class="pre">process_time_series</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.ScalarConjPrior.process_time_series" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">(t,</span> <span class="pre">x)</span></code>, where <code class="docutils literal notranslate"><span class="pre">t</span></code> is a normalized list of timestamps, and <code class="docutils literal notranslate"><span class="pre">x</span></code> is a <code class="docutils literal notranslate"><span class="pre">numpy</span></code> array
representing the input</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.ScalarConjPrior.get_time_series_values">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_time_series_values</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.ScalarConjPrior.get_time_series_values" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>numpy array representing the input <code class="docutils literal notranslate"><span class="pre">x</span></code></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.BetaBernoulli">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">merlion.utils.conj_priors.</span></span><span class="sig-name descname"><span class="pre">BetaBernoulli</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sample</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.BetaBernoulli" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#merlion.utils.conj_priors.ScalarConjPrior" title="merlion.utils.conj_priors.ScalarConjPrior"><code class="xref py py-class docutils literal notranslate"><span class="pre">ScalarConjPrior</span></code></a></p>
<p>Beta-Bernoulli conjugate prior for binary data. We assume the model</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align*}
X &amp;\sim \mathrm{Bernoulli}(\theta) \\
\theta &amp;\sim \mathrm{Beta}(\alpha, \beta)
\end{align*}\end{split}\]</div>
<p>The update rule for data <span class="math notranslate nohighlight">\(x_1, \ldots, x_n\)</span> is</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align*}
\alpha &amp;= \alpha + \sum_{i=1}^{n} \mathbb{I}[x_i = 1] \\
\beta &amp;= \beta + \sum_{i=1}^{n} \mathbb{I}[x_i = 0]
\end{align*}\end{split}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>sample</strong> – a sample used to initialize the prior.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.BetaBernoulli.posterior">
<span class="sig-name descname"><span class="pre">posterior</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_rv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_updated</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.BetaBernoulli.posterior" title="Permalink to this definition"></a></dt>
<dd><p>The posterior distribution of x is <span class="math notranslate nohighlight">\(\mathrm{Bernoulli}(\alpha / (\alpha + \beta))\)</span>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.BetaBernoulli.theta_posterior">
<span class="sig-name descname"><span class="pre">theta_posterior</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_rv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.BetaBernoulli.theta_posterior" title="Permalink to this definition"></a></dt>
<dd><p>The posterior distribution of <span class="math notranslate nohighlight">\(\theta\)</span> is <span class="math notranslate nohighlight">\(\mathrm{Beta}(\alpha, \beta)\)</span>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.BetaBernoulli.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.BetaBernoulli.update" title="Permalink to this definition"></a></dt>
<dd><p>Update the conjugate prior based on new observations x.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.BetaBernoulli.forecast">
<span class="sig-name descname"><span class="pre">forecast</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_stamps</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.BetaBernoulli.forecast" title="Permalink to this definition"></a></dt>
<dd><p>Return a posterior predictive interval for the time stamps given.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>time_stamps</strong> – a list of time stamps</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code>[<a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a>, <a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a>]</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">(forecast,</span> <span class="pre">stderr)</span></code>, where <code class="docutils literal notranslate"><span class="pre">forecast</span></code> is the expected posterior value and <code class="docutils literal notranslate"><span class="pre">stderr</span></code> is the
standard error of that forecast.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.NormInvGamma">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">merlion.utils.conj_priors.</span></span><span class="sig-name descname"><span class="pre">NormInvGamma</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sample</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.NormInvGamma" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#merlion.utils.conj_priors.ScalarConjPrior" title="merlion.utils.conj_priors.ScalarConjPrior"><code class="xref py py-class docutils literal notranslate"><span class="pre">ScalarConjPrior</span></code></a></p>
<p>Normal-InverseGamma conjugate prior. Following
<a class="reference external" href="https://en.wikipedia.org/wiki/Normal-inverse-gamma_distribution">Wikipedia</a> and
<a class="reference external" href="https://www.cs.ubc.ca/~murphyk/Papers/bayesGauss.pdf">Murphy (2007)</a>, we assume the model</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align*}
X &amp;\sim \mathcal{N}(\mu, \sigma^2) \\
\mu &amp;\sim \mathcal{N}(\mu_0, \sigma^2 / n) \\
\sigma^2 &amp;\sim \mathrm{InvGamma}(\alpha, \beta)
\end{align*}\end{split}\]</div>
<p>The update rule for data <span class="math notranslate nohighlight">\(x_1, \ldots, x_n\)</span> is</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align*}
\bar{x} &amp;= \frac{1}{n} \sum_{i = 1}^{n} x_i \\
\alpha &amp;= \alpha + n/2 \\
\beta &amp;= \beta + \frac{1}{2} \sum_{i = 1}^{n} (x_i - \bar{x})^2 + \frac{1}{2} (\mu_0 - \bar{x})^2 \\
\mu_0 &amp;= \frac{n_0}{n_0 + n} \mu_0 + \frac{n}{n_0 + n} \bar{x} \\
n_0 &amp;= n_0 + n
\end{align*}\end{split}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>sample</strong> – a sample used to initialize the prior.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.NormInvGamma.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.NormInvGamma.update" title="Permalink to this definition"></a></dt>
<dd><p>Update the conjugate prior based on new observations x.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.NormInvGamma.mu_posterior">
<span class="sig-name descname"><span class="pre">mu_posterior</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_rv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.NormInvGamma.mu_posterior" title="Permalink to this definition"></a></dt>
<dd><p>The posterior for <span class="math notranslate nohighlight">\(\mu\)</span> is <span class="math notranslate nohighlight">\(\text{Student-t}_{2\alpha}(\mu_0, \beta / (n \alpha))\)</span></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.NormInvGamma.sigma2_posterior">
<span class="sig-name descname"><span class="pre">sigma2_posterior</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sigma2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_rv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.NormInvGamma.sigma2_posterior" title="Permalink to this definition"></a></dt>
<dd><p>The posterior for <span class="math notranslate nohighlight">\(\sigma^2\)</span> is <span class="math notranslate nohighlight">\(\text{InvGamma}(\alpha, \beta)\)</span>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.NormInvGamma.posterior">
<span class="sig-name descname"><span class="pre">posterior</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_rv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_updated</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.NormInvGamma.posterior" title="Permalink to this definition"></a></dt>
<dd><p>The posterior for <span class="math notranslate nohighlight">\(x\)</span> is <span class="math notranslate nohighlight">\(\text{Student-t}_{2\alpha}(\mu_0, (n+1) \beta / (n \alpha))\)</span></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.NormInvGamma.forecast">
<span class="sig-name descname"><span class="pre">forecast</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_stamps</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.NormInvGamma.forecast" title="Permalink to this definition"></a></dt>
<dd><p>Return a posterior predictive interval for the time stamps given.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>time_stamps</strong> – a list of time stamps</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code>[<a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a>, <a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a>]</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">(forecast,</span> <span class="pre">stderr)</span></code>, where <code class="docutils literal notranslate"><span class="pre">forecast</span></code> is the expected posterior value and <code class="docutils literal notranslate"><span class="pre">stderr</span></code> is the
standard error of that forecast.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.MVNormInvWishart">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">merlion.utils.conj_priors.</span></span><span class="sig-name descname"><span class="pre">MVNormInvWishart</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sample</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.MVNormInvWishart" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#merlion.utils.conj_priors.ConjPrior" title="merlion.utils.conj_priors.ConjPrior"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConjPrior</span></code></a></p>
<p>Multivariate Normal-InverseWishart conjugate prior. Multivariate equivalent of Normal-InverseGamma.
Following <a class="reference external" href="https://www.cs.ubc.ca/~murphyk/Papers/bayesGauss.pdf">Murphy (2007)</a>, we assume the model</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align*}
X &amp;\sim \mathcal{N}_d(\mu, \Sigma) \\
\mu &amp;\sim \mathcal{N}_d(\mu_0, \Sigma / n) \\
\Sigma &amp;\sim \mathrm{InvWishart}_{\nu}(\Lambda)
\end{align*}\end{split}\]</div>
<p>The update rule for data <span class="math notranslate nohighlight">\(x_1, \ldots, x_n\)</span> is</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align*}
\bar{x} &amp;= \frac{1}{n} \sum_{i = 1}^{n} x_i \\
\nu &amp;= \nu + n/2 \\
\Lambda &amp;= \Lambda + \frac{n_0 n}{n_0 + n} (\mu_0 - \bar{x}) (\mu_0 - \bar{x})^T +
\sum_{i = 1}^{n} (x_i - \bar{x}) (x_i - \bar{x})^T \\
\mu_0 &amp;= \frac{n_0}{n_0 + n} \mu_0 + \frac{n}{n_0 + n} \bar{x} \\
n_0 &amp;= n_0 + n
\end{align*}\end{split}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>sample</strong> – a sample used to initialize the prior.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.MVNormInvWishart.process_time_series">
<span class="sig-name descname"><span class="pre">process_time_series</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.MVNormInvWishart.process_time_series" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">(t,</span> <span class="pre">x)</span></code>, where <code class="docutils literal notranslate"><span class="pre">t</span></code> is a normalized list of timestamps, and <code class="docutils literal notranslate"><span class="pre">x</span></code> is a <code class="docutils literal notranslate"><span class="pre">numpy</span></code> array
representing the input</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.MVNormInvWishart.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.MVNormInvWishart.update" title="Permalink to this definition"></a></dt>
<dd><p>Update the conjugate prior based on new observations x.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.MVNormInvWishart.mu_posterior">
<span class="sig-name descname"><span class="pre">mu_posterior</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_rv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.MVNormInvWishart.mu_posterior" title="Permalink to this definition"></a></dt>
<dd><p>The posterior for <span class="math notranslate nohighlight">\(\mu\)</span> is <span class="math notranslate nohighlight">\(\text{Student-t}_{\nu-d+1}(\mu_0, \Lambda / (n (\nu - d + 1)))\)</span></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.MVNormInvWishart.Sigma_posterior">
<span class="sig-name descname"><span class="pre">Sigma_posterior</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sigma2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_rv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.MVNormInvWishart.Sigma_posterior" title="Permalink to this definition"></a></dt>
<dd><p>The posterior for <span class="math notranslate nohighlight">\(\Sigma\)</span> is <span class="math notranslate nohighlight">\(\text{InvWishart}_{\nu}(\Lambda^{-1})\)</span></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.MVNormInvWishart.posterior">
<span class="sig-name descname"><span class="pre">posterior</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_rv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_updated</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.MVNormInvWishart.posterior" title="Permalink to this definition"></a></dt>
<dd><p>The posterior for <span class="math notranslate nohighlight">\(x\)</span> is <span class="math notranslate nohighlight">\(\text{Student-t}_{\nu-d+1}(\mu_0, (n + 1) \Lambda / (n (\nu - d + 1)))\)</span></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.MVNormInvWishart.forecast">
<span class="sig-name descname"><span class="pre">forecast</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_stamps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'forecast'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.MVNormInvWishart.forecast" title="Permalink to this definition"></a></dt>
<dd><p>Return a posterior predictive interval for the time stamps given.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>time_stamps</strong> – a list of time stamps</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code>[<a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a>, <a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a>]</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">(forecast,</span> <span class="pre">stderr)</span></code>, where <code class="docutils literal notranslate"><span class="pre">forecast</span></code> is the expected posterior value and <code class="docutils literal notranslate"><span class="pre">stderr</span></code> is the
standard error of that forecast.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.BayesianLinReg">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">merlion.utils.conj_priors.</span></span><span class="sig-name descname"><span class="pre">BayesianLinReg</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sample</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.BayesianLinReg" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#merlion.utils.conj_priors.ConjPrior" title="merlion.utils.conj_priors.ConjPrior"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConjPrior</span></code></a></p>
<p>Bayesian Ordinary Linear Regression conjugate prior, which models a univariate input as a function of time.
Following <a class="reference external" href="https://en.wikipedia.org/wiki/Bayesian_linear_regression">Wikipedia</a>, we assume the model</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align*}
x(t) &amp;\sim \mathcal{N}(m t + b, \sigma^2) \\
w &amp;\sim \mathcal{N}((m_0, b_0), \sigma^2 \Lambda_0^{-1}) \\
\sigma^2 &amp;\sim \mathrm{InvGamma}(\alpha, \beta)
\end{align*}\end{split}\]</div>
<p>Consider new data <span class="math notranslate nohighlight">\((t_1, x_1), \ldots, (t_n, x_n)\)</span>. Let <span class="math notranslate nohighlight">\(T \in \mathbb{R}^{n \times 2}\)</span> be
the matrix obtained by stacking the row vector of times with an all-ones row vector. Let
<span class="math notranslate nohighlight">\(w = (m, b) \in \mathbb{R}^{2}\)</span> be the full weight vector. Let <span class="math notranslate nohighlight">\(x \in \mathbb{R}^{n}\)</span> denote
all observed values. Then we have the update rule</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align*}
w_{OLS} &amp;= (T^T T)^{-1} T^T x \\
\Lambda_n &amp;= \Lambda_0 + T^T T \\
w_n &amp;= (\Lambda_0 + T^T T)^{-1} (\Lambda_0 w_0 + T^T T w_{OLS}) \\
\alpha_n &amp;= \alpha_0 + n / 2 \\
\beta_n &amp;= \beta_0 + \frac{1}{2}(x^T x + w_0^T \Lambda_0 w_0 - w_n^T \Lambda_n w_n)
\end{align*}\end{split}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>sample</strong> – a sample used to initialize the prior.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.BayesianLinReg.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.BayesianLinReg.update" title="Permalink to this definition"></a></dt>
<dd><p>Update the conjugate prior based on new observations x.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.BayesianLinReg.posterior_explicit">
<span class="sig-name descname"><span class="pre">posterior_explicit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_rv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_updated</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.BayesianLinReg.posterior_explicit" title="Permalink to this definition"></a></dt>
<dd><p>Let <span class="math notranslate nohighlight">\(\Lambda_n, \alpha_n, \beta_n\)</span> be the posterior values obtained by updating
the model on data <span class="math notranslate nohighlight">\((t_1, x_1), \ldots, (t_n, x_n)\)</span>. The predictive posterior has PDF</p>
<div class="math notranslate nohighlight">
\[\begin{align*}
P((t, x)) &amp;= \frac{1}{(2 \pi)^{-n/2}} \sqrt{\frac{\det \Lambda_0}{\det \Lambda_n}}
\frac{\beta_0^{\alpha_0}}{\beta_n^{\alpha_n}}\frac{\Gamma(\alpha_n)}{\Gamma(\alpha_0)}
\end{align*}\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.BayesianLinReg.posterior">
<span class="sig-name descname"><span class="pre">posterior</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_rv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_updated</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.BayesianLinReg.posterior" title="Permalink to this definition"></a></dt>
<dd><p>Naive computation of the posterior using Bayes Rule, i.e.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\hat{\sigma}^2 &amp;= \mathbb{E}[\sigma^2] \\
\hat{w} &amp;= \mathbb{E}[w \mid \sigma^2 = \hat{\sigma}^2] \\
p(x \mid t) &amp;= \frac{
p(w = \hat{w}, \sigma^2 = \hat{\sigma}^2)
p(x \mid t, w = \hat{w}, \sigma^2 = \hat{\sigma}^2)}{
p(w = \hat{w}, \sigma^2 = \hat{\sigma}^2 \mid x, t)}\end{split}\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.BayesianLinReg.forecast">
<span class="sig-name descname"><span class="pre">forecast</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_stamps</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.BayesianLinReg.forecast" title="Permalink to this definition"></a></dt>
<dd><p>Return a posterior predictive interval for the time stamps given.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>time_stamps</strong> – a list of time stamps</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code>[<a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a>, <a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a>]</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">(forecast,</span> <span class="pre">stderr)</span></code>, where <code class="docutils literal notranslate"><span class="pre">forecast</span></code> is the expected posterior value and <code class="docutils literal notranslate"><span class="pre">stderr</span></code> is the
standard error of that forecast.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.BayesianMVLinReg">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">merlion.utils.conj_priors.</span></span><span class="sig-name descname"><span class="pre">BayesianMVLinReg</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sample</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.BayesianMVLinReg" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#merlion.utils.conj_priors.ConjPrior" title="merlion.utils.conj_priors.ConjPrior"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConjPrior</span></code></a></p>
<p>Bayesian multivariate linear regression conjugate prior, which models a multivariate input as a function of time.
Following <a class="reference external" href="https://en.wikipedia.org/wiki/Bayesian_multivariate_linear_regression">Wikipedia</a> and
<a class="reference external" href="https://www.jstor.org/stable/2238083">Geisser (1965)</a>, we assume the model</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align*}
X(t) &amp;\sim \mathcal{N}_{d}(m t + b, \Sigma) \\
(m, b) &amp;\sim \mathcal{N}_{2d}((m_0, b_0), \Sigma \otimes \Lambda_0^{-1}) \\
\Sigma &amp;\sim \mathrm{InvWishart}_{\nu}(V_0) \\
\end{align*}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\((m, b)\)</span> is the concatenation of the vectors <span class="math notranslate nohighlight">\(m\)</span> and <span class="math notranslate nohighlight">\(b\)</span>,
<span class="math notranslate nohighlight">\(\Lambda_0 \in \mathbb{R}^{2 \times 2}\)</span>, and <span class="math notranslate nohighlight">\(\otimes\)</span> is the Kronecker product.
Consider new data <span class="math notranslate nohighlight">\((t_1, x_1), \ldots, (t_n, x_n)\)</span>. Let <span class="math notranslate nohighlight">\(T \in \mathbb{R}^{n \times 2}\)</span> be
the matrix obtained by stacking the row vector of times with an all-ones row vector. Let
<span class="math notranslate nohighlight">\(W = [m, b]^T \in \mathbb{R}^{2 \times d}\)</span> be the full weight matrix. Let
<span class="math notranslate nohighlight">\(X \in \mathbb{R}^{n \times d}\)</span> be the matrix of observed <span class="math notranslate nohighlight">\(x\)</span> values. Then we have the update rule</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align*}
\nu_n &amp;= \nu_0 + n \\
W_n &amp;= (\Lambda_0 + T^T T)^{-1}(\Lambda_0 W_0 + T^T X) \\
V_n &amp;= V_0 + (X - TW_n)^T (X - TW_n) + (W_n - W_0)^T \Lambda_0 (W_n - W_0) \\
\Lambda_n &amp;= \Lambda_0 + T^T T \\
\end{align*}\end{split}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>sample</strong> – a sample used to initialize the prior.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.BayesianMVLinReg.process_time_series">
<span class="sig-name descname"><span class="pre">process_time_series</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.BayesianMVLinReg.process_time_series" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">(t,</span> <span class="pre">x)</span></code>, where <code class="docutils literal notranslate"><span class="pre">t</span></code> is a normalized list of timestamps, and <code class="docutils literal notranslate"><span class="pre">x</span></code> is a <code class="docutils literal notranslate"><span class="pre">numpy</span></code> array
representing the input</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.BayesianMVLinReg.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.BayesianMVLinReg.update" title="Permalink to this definition"></a></dt>
<dd><p>Update the conjugate prior based on new observations x.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.BayesianMVLinReg.posterior_explicit">
<span class="sig-name descname"><span class="pre">posterior_explicit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_rv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_updated</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.BayesianMVLinReg.posterior_explicit" title="Permalink to this definition"></a></dt>
<dd><p>Let <span class="math notranslate nohighlight">\(\Lambda_n, \nu_n, V_n\)</span> be the posterior values obtained by updating
the model on data <span class="math notranslate nohighlight">\((t_1, x_1), \ldots, (t_n, x_n)\)</span>. The predictive posterior has PDF</p>
<div class="math notranslate nohighlight">
\[\begin{align*}
P((t, x)) &amp;= \frac{1}{(2 \pi)^{-nd/2}} \sqrt{\frac{\det \Lambda_0}{\det \Lambda_n}}
\frac{\det(V_0/2)^{\nu_0/2}}{\det(V_n/2)^{\nu_n/2}}\frac{\Gamma_d(\nu_n/2)}{\Gamma_d(\nu_0 / 2)}
\end{align*}\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.BayesianMVLinReg.posterior">
<span class="sig-name descname"><span class="pre">posterior</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_rv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_updated</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.BayesianMVLinReg.posterior" title="Permalink to this definition"></a></dt>
<dd><p>Naive computation of the posterior using Bayes Rule, i.e.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\hat{\Sigma} &amp;= \mathbb{E}[\Sigma] \\
\hat{W} &amp;= \mathbb{E}[W \mid \Sigma = \hat{\Sigma}] \\
p(X \mid t) &amp;= \frac{
p(W = \hat{W}, \Sigma = \hat{\Sigma})
p(X \mid t, W = \hat{W}, \Sigma = \hat{\Sigma})}{
p(W = \hat{W}, \Sigma = \hat{\Sigma} \mid x, t)}\end{split}\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.conj_priors.BayesianMVLinReg.forecast">
<span class="sig-name descname"><span class="pre">forecast</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_stamps</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.conj_priors.BayesianMVLinReg.forecast" title="Permalink to this definition"></a></dt>
<dd><p>Return a posterior predictive interval for the time stamps given.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>time_stamps</strong> – a list of time stamps</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code>[<a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a>, <a class="reference internal" href="#merlion.utils.time_series.TimeSeries" title="merlion.utils.time_series.TimeSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a>]</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">(forecast,</span> <span class="pre">stderr)</span></code>, where <code class="docutils literal notranslate"><span class="pre">forecast</span></code> is the expected posterior value and <code class="docutils literal notranslate"><span class="pre">stderr</span></code> is the
standard error of that forecast.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-merlion.utils.istat">
<span id="merlion-utils-istat-module"></span><h2>merlion.utils.istat module<a class="headerlink" href="#module-merlion.utils.istat" title="Permalink to this heading"></a></h2>
<p>Incremental computation of time series statistics.</p>
<dl class="py class">
<dt class="sig sig-object py" id="merlion.utils.istat.IStat">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">merlion.utils.istat.</span></span><span class="sig-name descname"><span class="pre">IStat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.istat.IStat" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>An abstract base class for computing various statistics incrementally,
with emphasis on recency-weighted variants.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>value</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]) – Initial value of the statistic. Defaults to None.</p></li>
<li><p><strong>n</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Initial sample size. Defaults to 0.</p></li>
</ul>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="merlion.utils.istat.IStat.n">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">n</span></span><a class="headerlink" href="#merlion.utils.istat.IStat.n" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="merlion.utils.istat.IStat.value">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">value</span></span><a class="headerlink" href="#merlion.utils.istat.IStat.value" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.istat.IStat.add">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">add</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.istat.IStat.add" title="Permalink to this definition"></a></dt>
<dd><p>Add a new value to update the statistic.
:param x: new value to add to the sample.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.istat.IStat.drop">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">drop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.istat.IStat.drop" title="Permalink to this definition"></a></dt>
<dd><p>Drop a value to update the statistic.
:param x: value to drop from the sample.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.istat.IStat.add_batch">
<span class="sig-name descname"><span class="pre">add_batch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">batch</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.istat.IStat.add_batch" title="Permalink to this definition"></a></dt>
<dd><p>Add a batch of new values to update the statistic.
:type batch: <code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]
:param batch: new values to add to the sample.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.istat.IStat.drop_batch">
<span class="sig-name descname"><span class="pre">drop_batch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">batch</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.istat.IStat.drop_batch" title="Permalink to this definition"></a></dt>
<dd><p>Drop a batch of new values to update the statistic.
:type batch: <code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]
:param batch: new values to add to the sample.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="merlion.utils.istat.Mean">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">merlion.utils.istat.</span></span><span class="sig-name descname"><span class="pre">Mean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.istat.Mean" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#merlion.utils.istat.IStat" title="merlion.utils.istat.IStat"><code class="xref py py-class docutils literal notranslate"><span class="pre">IStat</span></code></a></p>
<p>Class for incrementally computing the mean of a series of numbers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>value</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]) – Initial value of the statistic. Defaults to None.</p></li>
<li><p><strong>n</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Initial sample size. Defaults to 0.</p></li>
</ul>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="merlion.utils.istat.Mean.value">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">value</span></span><a class="headerlink" href="#merlion.utils.istat.Mean.value" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.istat.Mean.add">
<span class="sig-name descname"><span class="pre">add</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.istat.Mean.add" title="Permalink to this definition"></a></dt>
<dd><p>Add a new value to update the statistic.
:param x: new value to add to the sample.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.istat.Mean.drop">
<span class="sig-name descname"><span class="pre">drop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.istat.Mean.drop" title="Permalink to this definition"></a></dt>
<dd><p>Drop a value to update the statistic.
:param x: value to drop from the sample.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="merlion.utils.istat.Variance">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">merlion.utils.istat.</span></span><span class="sig-name descname"><span class="pre">Variance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ex_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ex2_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ddof</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.istat.Variance" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#merlion.utils.istat.IStat" title="merlion.utils.istat.IStat"><code class="xref py py-class docutils literal notranslate"><span class="pre">IStat</span></code></a></p>
<p>Class for incrementally computing the variance of a series of numbers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ex_value</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]) – Initial value of the first moment (mean).</p></li>
<li><p><strong>ex2_value</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]) – Initial value of the second moment.</p></li>
<li><p><strong>n</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Initial sample size.</p></li>
<li><p><strong>ddof</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – The delta degrees of freedom to use when correcting
the estimate of the variance.</p></li>
</ul>
</dd>
</dl>
<div class="math notranslate nohighlight">
\[\text{Var}(x_i) = \text{E}(x_i^2) - \text{E}(x_i)^2\]</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="merlion.utils.istat.Variance.mean_class">
<span class="sig-name descname"><span class="pre">mean_class</span></span><a class="headerlink" href="#merlion.utils.istat.Variance.mean_class" title="Permalink to this definition"></a></dt>
<dd><p>alias of <a class="reference internal" href="#merlion.utils.istat.Mean" title="merlion.utils.istat.Mean"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mean</span></code></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.istat.Variance.add">
<span class="sig-name descname"><span class="pre">add</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.istat.Variance.add" title="Permalink to this definition"></a></dt>
<dd><p>Add a new value to update the statistic.
:param x: new value to add to the sample.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.istat.Variance.drop">
<span class="sig-name descname"><span class="pre">drop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.istat.Variance.drop" title="Permalink to this definition"></a></dt>
<dd><p>Drop a value to update the statistic.
:param x: value to drop from the sample.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="merlion.utils.istat.Variance.true_value">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">true_value</span></span><a class="headerlink" href="#merlion.utils.istat.Variance.true_value" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="merlion.utils.istat.Variance.corrected_value">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">corrected_value</span></span><a class="headerlink" href="#merlion.utils.istat.Variance.corrected_value" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="merlion.utils.istat.Variance.value">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">value</span></span><a class="headerlink" href="#merlion.utils.istat.Variance.value" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="merlion.utils.istat.Variance.sd">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">sd</span></span><a class="headerlink" href="#merlion.utils.istat.Variance.sd" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="merlion.utils.istat.Variance.se">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">se</span></span><a class="headerlink" href="#merlion.utils.istat.Variance.se" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="merlion.utils.istat.ExponentialMovingAverage">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">merlion.utils.istat.</span></span><span class="sig-name descname"><span class="pre">ExponentialMovingAverage</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">recency_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.istat.ExponentialMovingAverage" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#merlion.utils.istat.Mean" title="merlion.utils.istat.Mean"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mean</span></code></a></p>
<p>Class for incrementally computing the exponential moving average of a series of numbers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>recency_weight</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Recency weight to use when updating the
exponential moving average.</p>
</dd>
</dl>
<p>Letting <code class="docutils literal notranslate"><span class="pre">w</span></code> be the recency weight,</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align*}
\text{EMA}_w(x_0) &amp; = x_0 \\
\text{EMA}_w(x_t) &amp; = w \cdot x_t + (1-w) \cdot \text{EMA}_w(x_{t-1})
\end{align*}\end{split}\]</div>
<dl class="py property">
<dt class="sig sig-object py" id="merlion.utils.istat.ExponentialMovingAverage.recency_weight">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">recency_weight</span></span><a class="headerlink" href="#merlion.utils.istat.ExponentialMovingAverage.recency_weight" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="merlion.utils.istat.ExponentialMovingAverage.value">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">value</span></span><a class="headerlink" href="#merlion.utils.istat.ExponentialMovingAverage.value" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.istat.ExponentialMovingAverage.drop">
<span class="sig-name descname"><span class="pre">drop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.istat.ExponentialMovingAverage.drop" title="Permalink to this definition"></a></dt>
<dd><p>Exponential Moving Average does not support dropping values</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="merlion.utils.istat.RecencyWeightedVariance">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">merlion.utils.istat.</span></span><span class="sig-name descname"><span class="pre">RecencyWeightedVariance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">recency_weight</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.istat.RecencyWeightedVariance" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#merlion.utils.istat.Variance" title="merlion.utils.istat.Variance"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variance</span></code></a></p>
<p>Class for incrementally computing the recency-weighted variance of a series of numbers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>recency_weight</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Recency weight to use when updating the
recency weighted variance.</p>
</dd>
</dl>
<p>Letting <code class="docutils literal notranslate"><span class="pre">w</span></code> be the recency weight,</p>
<div class="math notranslate nohighlight">
\[\text{RWV}_w(x_t) = \text{EMA}_w({x^2_t}) - \text{EMA}_w(x_t)^2\]</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="merlion.utils.istat.RecencyWeightedVariance.mean_class">
<span class="sig-name descname"><span class="pre">mean_class</span></span><a class="headerlink" href="#merlion.utils.istat.RecencyWeightedVariance.mean_class" title="Permalink to this definition"></a></dt>
<dd><p>alias of <a class="reference internal" href="#merlion.utils.istat.ExponentialMovingAverage" title="merlion.utils.istat.ExponentialMovingAverage"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExponentialMovingAverage</span></code></a></p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="merlion.utils.istat.RecencyWeightedVariance.recency_weight">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">recency_weight</span></span><a class="headerlink" href="#merlion.utils.istat.RecencyWeightedVariance.recency_weight" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlion.utils.istat.RecencyWeightedVariance.drop">
<span class="sig-name descname"><span class="pre">drop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlion.utils.istat.RecencyWeightedVariance.drop" title="Permalink to this definition"></a></dt>
<dd><p>Recency Weighted Variance does not support dropping values</p>
</dd></dl>

</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="merlion.evaluate.html" class="btn btn-neutral float-left" title="merlion.evaluate package" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="ts_datasets.html" class="btn btn-neutral float-right" title="ts_datasets: Easy Data Loading" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, salesforce.com, inc..</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  

  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      <span class="fa fa-book"> Versions</span>
      latest
      <span class="fa fa-caret-down"></span>
    </span>
    <div class="rst-other-versions">
      
      <dl>
        <dt>Versions</dt>
        
           <strong> 
          
          <dd><a href="../latest/index.html">latest</a></dd>
           </strong> 
        
          
          
          <dd><a href="../v1.3.1/index.html">v1.3.1</a></dd>
          
        
          
          
          <dd><a href="../v1.3.0/index.html">v1.3.0</a></dd>
          
        
          
          
          <dd><a href="../v1.2.5/index.html">v1.2.5</a></dd>
          
        
          
          
          <dd><a href="../v1.2.4/index.html">v1.2.4</a></dd>
          
        
          
          
          <dd><a href="../v1.2.3/index.html">v1.2.3</a></dd>
          
        
          
          
          <dd><a href="../v1.2.2/index.html">v1.2.2</a></dd>
          
        
          
          
          <dd><a href="../v1.2.1/index.html">v1.2.1</a></dd>
          
        
          
          
          <dd><a href="../v1.2.0/index.html">v1.2.0</a></dd>
          
        
          
          
          <dd><a href="../v1.1.3/index.html">v1.1.3</a></dd>
          
        
          
          
          <dd><a href="../v1.1.2/index.html">v1.1.2</a></dd>
          
        
          
          
          <dd><a href="../v1.1.1/index.html">v1.1.1</a></dd>
          
        
          
          
          <dd><a href="../v1.1.0/index.html">v1.1.0</a></dd>
          
        
          
          
          <dd><a href="../v1.0.2/index.html">v1.0.2</a></dd>
          
        
          
          
          <dd><a href="../v1.0.1/index.html">v1.0.1</a></dd>
          
        
          
          
          <dd><a href="../v1.0.0/index.html">v1.0.0</a></dd>
          
        
      </dl>
      
    </div>
  </div>

 <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>